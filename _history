{"entries":[{"timestamp":1758398178308,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":182,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":3741,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":115,"length1":192,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":232,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1758398732003,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"////////////////////\r\n//################//\r\n//##            ##//\r\n//##  nezha.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum RJPort {\r\n    //% block=\"port J1\"\r\n    //% bloc.loc.nl=\"poort J1\"\r\n    J1,\r\n    //% block=\"port J2\"\r\n    //% bloc.loc.nl=\"poort J2\"\r\n    J2,\r\n    //% block=\"port J3\"\r\n    //% bloc.loc.nl=\"poort J3\"\r\n    J3,\r\n    //% block=\"port J4\"\r\n    //% bloc.loc.nl=\"poort J4\"\r\n    J4,\r\n}\r\n\r\nenum RJLine {\r\n    //% block=\"line A\"\r\n    LA,\r\n    //% block=\"line B\"\r\n    LB,\r\n}\r\n\r\nenum MotorPort {\r\n    //% block=\"M1\"\r\n    M1,\r\n    //% block=\"M2\"\r\n    M2,\r\n    //% block=\"M3\"\r\n    M3,\r\n    //% block=\"M4\"\r\n    M4,\r\n}\r\n\r\nenum MotorPosition {\r\n    Left,\r\n    Right,\r\n    FrontLeft,\r\n    FrontRight,\r\n    RearLeft,\r\n    RearRight,\r\n}\r\n\r\ntype Motor = { Port: MotorPort, Revert: boolean }\r\n\r\nnamespace Nezha {\r\n\r\n    let AnalogRJ = [AnalogPin.P8, AnalogPin.P1,\r\n    AnalogPin.P12, AnalogPin.P2,\r\n    AnalogPin.P14, AnalogPin.P13,\r\n    AnalogPin.P16, AnalogPin.P15]\r\n\r\n    let DigitalRJ = [DigitalPin.P8, DigitalPin.P1,\r\n    DigitalPin.P12, DigitalPin.P2,\r\n    DigitalPin.P14, DigitalPin.P13,\r\n    DigitalPin.P16, DigitalPin.P15]\r\n\r\n    let MFL: Motor = { Port: MotorPort.M1, Revert: false }\r\n    let MRL: Motor = { Port: MotorPort.M2, Revert: false }\r\n    let MFR: Motor = { Port: MotorPort.M3, Revert: false }\r\n    let MRR: Motor = { Port: MotorPort.M4, Revert: false }\r\n\r\n    export function analogPin(port: RJPort, line: RJLine): AnalogPin {\r\n        return AnalogRJ[port * 2 + line]\r\n    }\r\n\r\n    export function digitalPin(port: RJPort, line: RJLine): DigitalPin {\r\n        return DigitalRJ[port * 2 + line]\r\n    }\r\n\r\n    export function setTwoWheelMotors(left: Motor, right: Motor) {\r\n        MFL = left\r\n        MFR = right\r\n    }\r\n\r\n    export function setFourWheelMotors(frontleft: Motor, frontright: Motor,\r\n        rearleft: Motor, rearright: Motor) {\r\n        MFL = frontleft\r\n        MFR = frontright\r\n        MRL = rearleft\r\n        MFR = rearright\r\n    }\r\n\r\n    export function getMotor(position: MotorPosition): Motor {\r\n        switch (position) {\r\n            case MotorPosition.Left: return MFL\r\n            case MotorPosition.Right: return MFR\r\n            case MotorPosition.FrontLeft: return MFL\r\n            case MotorPosition.FrontRight: return MFR\r\n            case MotorPosition.RearLeft: return MRL\r\n            case MotorPosition.RearRight: return MRR\r\n        }\r\n        return MFL\r\n    }\r\n}\r\n\r\n\r\n////////////////////////\r\n//####################//\r\n//##                ##//\r\n//##  px-switch.ts  ##//\r\n//##                ##//\r\n//####################//\r\n////////////////////////\r\n\r\n/*\r\nThe code below is a refactoring of:\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nMIT-license.\r\n*/\r\n\r\nenum Switch {\r\n    //% block=\"released\"\r\n    //% block.loc.nl=\"losgelaten\"\r\n    Released,\r\n    //% block=\"pressed\"\r\n    //% block.loc.nl=\"ingedrukt\"\r\n    Pressed,\r\n}\r\n\r\nnamespace PxSwitch {\r\n\r\n    export class Device {\r\n\r\n        port: RJPort\r\n\r\n        constructor(port: RJPort) {\r\n            this.port = port\r\n        }\r\n\r\n        read(): Switch {\r\n            let pin = Nezha.digitalPin(this.port, RJLine.LA)\r\n            pins.setPull(pin, PinPullMode.PullUp)\r\n            let sensor = pins.digitalReadPin(pin)\r\n            return (sensor ? Switch.Released : Switch.Pressed)\r\n        }\r\n    }\r\n\r\n    export function create(port: RJPort): Device {\r\n        let device = new Device(port)\r\n        return device\r\n    }\r\n}\r\n\r\n\r\nlet sw = PxSwitch.create(RJPort.J4)\r\nbasic.forever(function() {\r\n    if (sw.read() == Switch.Pressed)\r\n        basic.showIcon(IconNames.Happy)\r\n    else\r\n        basic.showIcon(IconNames.Sad)\r\n})"]]}]}]},{"timestamp":1758398852835,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":7521,"diffs":[[1,""]]}]}]},{"timestamp":1758405148359,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":4,"diffs":[[1,""]]}]}]},{"timestamp":1758405197353,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":154,"diffs":[[1,""]]},{"start1":2,"length1":197,"diffs":[[1,""]]},{"start1":4,"length1":3083,"diffs":[[1,""]]},{"start1":7525,"length1":1144,"diffs":[[1,""]]}]}]},{"timestamp":1758405794609,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11188,"length1":527,"diffs":[[1,""]]},{"start1":12041,"length1":25,"diffs":[[1,"//% block.loc.nl=\"Sumo-worstelen\"\r\n"]]},{"start1":12102,"length1":4407,"diffs":[[1,""]]}]}]},{"timestamp":1758406224090,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12907,"length1":86,"diffs":[[1,"    export function onEventLeftOutOfField(side: Side, programmableCode: () => void): void {\r\n"]]}]}]},{"timestamp":1758441424391,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12907,"length1":88,"diffs":[[1,"    export function oeftOutOfField(side: Side, programmableCode: () => void): void {\r\n"]]}]}]},{"timestamp":1758441426124,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12515,"length1":37,"diffs":[[1,""]]},{"start1":12907,"length1":115,"diffs":[[1,"    export function onleftOutOfField(side: Side, programmableCode: () => void): void {\r\n"]]},{"start1":13020,"length1":236,"diffs":[[1,"            case Side.Both: EventBothOutOfField = programmableCode; break;\r\n            case Side.Left: EventLeftOutOfField = programmableCode; break;\r\n            case Side.Right: EventRightOutOfField = programmableCode; break;\r\n"]]}]}]},{"timestamp":1758441996951,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12944,"length1":124,"diffs":[[1,"    export function onLeftOutOfField(side: Side, code: (prm:number) => voi\r\n        outOfFieldHandler = code(prm)\r\n        switch (side) {\r\n            case Side.Both: bothOutOfFieldHandler = programmableCode; break;\r\n            case Side.Left: leftOutOfFieldHandler = programmableCode; break;\r\n            case Side.Right: rightOutOfFieldHandler = programmableCode; break;\r\n        }\r\n"]]},{"start1":13340,"length1":0,"diffs":[[1,"\r\n"]]}]}]},{"timestamp":1758442574457,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12944,"length1":122,"diffs":[[1,"    export function onOutOfField(side: Side, code: (prm:number) => void) {\r\n        outOfFieldHandler = () => {code(side)}\r\n"]]}]}]},{"timestamp":1758442981909,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":13329,"length1":213,"diffs":[[1,"            case Bend.None: Cutebot.setSpeed(speed, speed); break;\r\n            case Bend.Left: Cutebot.setSpeed(speed / 2, speed); break;\r\n            case Bend.Right: Cutebot.setSpeed(speed, speed / 2); break;\r\n"]]},{"start1":13679,"length1":44,"diffs":[[1,"        let cm = Cutebot.readDistance()\r\n"]]},{"start1":13749,"length1":36,"diffs":[[1,"        Cutebot.setSpeed(100, 100)\r\n"]]},{"start1":13794,"length1":0,"diffs":[[1,"    //% block=\"the opponent is close\"\r\n    //% block.loc.nl=\"de tegenstander dichtbij is\"\r\n    export function nearOpponent(): boolean {\r\n        let val = NEAR\r\n        NEAR = false\r\n        return val\r\n    }\r\n\r\n"]]},{"start1":14133,"length1":58,"diffs":[[1,"        NEAR = false\r\n        let cm = Cutebot.readDistance()\r\n        if (cm > DIAMETER) return\r\n        let tm = input.runningTime() + cm * 1000 / 25\r\n        Cutebot.setSpeed(20, 20)\r\n"]]},{"start1":14334,"length1":44,"diffs":[[1,"            cm = Cutebot.readDistance()\r\n"]]},{"start1":14409,"length1":40,"diffs":[[1,"                Cutebot.setSpeed(0, 0)\r\n"]]},{"start1":14544,"length1":32,"diffs":[[1,"        Cutebot.setSpeed(0, 0)\r\n        NEAR = true\r\n"]]},{"start1":14734,"length1":125,"diffs":[[1,"        Cutebot.setSpeed(-15, 15)\r\n        while (Cutebot.readDistance() > DIAMETER) { }\r\n        Cutebot.setSpeed(0, 0)\r\n"]]},{"start1":15089,"length1":41,"diffs":[[1,"        Cutebot.ledColor(led, color)\r\n"]]},{"start1":15309,"length1":51,"diffs":[[1,"        Cutebot.ledColor(Led.Both, Color.None)\r\n"]]},{"start1":15588,"length1":81,"diffs":[[1,"            if (on) {\r\n                LEDS.setClear()\r\n"]]}]}]},{"timestamp":1758443578627,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12656,"length1":37,"diffs":[[1,""]]},{"start1":13947,"length1":42,"diffs":[[1,""]]},{"start1":14039,"length1":39,"diffs":[[1,"            if (cm > DIAMETER) {\r\n"]]},{"start1":14153,"length1":52,"diffs":[[1,"        } while (cm > 20 && input.runningTime() < tm)\r\n"]]},{"start1":14412,"length1":63,"diffs":[[1,"        while (CutebotPro.readDistance() > DIAMETER) { }\r\n"]]},{"start1":15321,"length1":18,"diffs":[[1,"                LEDS.show()\r\n            }\r\n            else {\r\n"]]},{"start1":15445,"length1":0,"diffs":[[1,"            }\r\n"]]},{"start1":15482,"length1":45,"diffs":[[1,"            NezhaBrick.twoWheelSpeed(speed, -speed)\r\n"]]},{"start1":15632,"length1":99,"diffs":[[1,"            if (on) {\r\n                LEDS.setClear()\r\n                LEDS.show()\r\n            }\r\n            else {\r\n"]]},{"start1":15812,"length1":0,"diffs":[[1,"            }\r\n"]]},{"start1":15849,"length1":45,"diffs":[[1,"            NezhaBrick.twoWheelSpeed(speed, -speed)\r\n"]]},{"start1":16183,"length1":94,"diffs":[[1,"            NezhaBrick.twoWheelSpeed(30, 30)\r\n"]]},{"start1":16259,"length1":96,"diffs":[[1,"            LEDS.setClear()\r\n            LEDS.show()\r\n            NezhaBrick.twoWheelSpeed(-30, -30)\r\n"]]},{"start1":16402,"length1":32,"diffs":[[1,"        NezhaBrick.twoWheelSpeed(0, 0)\r\n"]]}]}]},{"timestamp":1758444019826,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12254,"length1":49,"diffs":[[1,""]]},{"start1":16508,"length1":135,"diffs":[[1,"}"]]}]}]},{"timestamp":1758444591018,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12564,"length1":32,"diffs":[[1,"let outOfFieldHandler: prmhandler\r\n"]]}]}]},{"timestamp":1758445636386,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12564,"length1":34,"diffs":[[1,"let outOfFieldHandler: handler\r\n"]]}]}]},{"timestamp":1758445653206,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12305,"length1":60,"diffs":[[1,""]]},{"start1":12480,"length1":27,"diffs":[[1,""]]},{"start1":12564,"length1":0,"diffs":[[1,"let outLeOfFieldHandler: handler\r\n\r\n"]]}]}]},{"timestamp":1758446247121,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12305,"length1":0,"diffs":[[1,"// Out-Of-Field handlers\r\n"]]},{"start1":12540,"length1":52,"diffs":[[1,"        if (isOOFHandler)\r\n"]]},{"start1":12792,"length1":491,"diffs":[[1,"    //% subcategory=\"Bewegen\"\r\n"]]},{"start1":12945,"length1":0,"diffs":[[1,"    //% color=\"#FFCC00\"\r\n    //% block=\"when %side is out of the field\"\r\n    //% block.loc.nl=\"wanneer %side buiten het speelveld is\"\r\n    export function onOutOfField(side: Side, code: (prm:number) => prmhandler) {\r\n        outOfFieldHandler = code(side)\r\n    }\r\n\r\n"]]},{"start1":14173,"length1":51,"diffs":[[1,""]]}]}]},{"timestamp":1758446846645,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11470,"length1":79,"diffs":[[1,"    //% block=\"both sides\"\r\n    //% block.loc.nl=\"beide kanten\"\r\n"]]},{"start1":13035,"length1":83,"diffs":[[1,"    //% block=\"\"\r\n    //% block=\"\"\r\n"]]},{"start1":13153,"length1":198,"diffs":[[1,"            case Side.Both:\r\n            case Side.Left:\r\n            case Side.Right:    return CutebotPro\r\n"]]},{"start1":13273,"length1":22,"diffs":[[1,""]]},{"start1":16954,"length1":364,"diffs":[[1,"basic.forever(function() {\r\n})\r\n"]]}]}]},{"timestamp":1758447302038,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12651,"length1":41,"diffs":[[1,""]]},{"start1":13277,"length1":135,"diffs":[[1,"            case Side.Left:     return CutebotPro.isTrackAtLeft()\r\n            case Side.Right:    return CutebotPro.isTrackAtRight()\r\n"]]},{"start1":17436,"length1":0,"diffs":[[1,"    else\r\n        basic.showIcon(IconNames.Happy)\r\n"]]}]}]},{"timestamp":1758447799069,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":7999,"length1":33,"diffs":[[1,"        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n"]]},{"start1":8473,"length1":33,"diffs":[[1,"        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n"]]},{"start1":8944,"length1":33,"diffs":[[1,"        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n"]]},{"start1":9387,"length1":33,"diffs":[[1,"        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n"]]},{"start1":12651,"length1":33,"diffs":[[1,"        basic.showIcon(IconNames.Happy)\r\n"]]}]}]},{"timestamp":1758448351043,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":9962,"length1":0,"diffs":[[1,"\r\n"]]},{"start1":12255,"length1":200,"diffs":[[1,"            case Side.Both:     return CutebotPro.isOnTrack()\r\n            case Side.Left:     return CutebotPro.isTrackAtRight()\r\n            case Side.Right:    return CutebotPro.isTrackAtLeft()\r\n"]]},{"start1":16169,"length1":67,"diffs":[[1,"outOfFieldHandler = () => {\r\n    if (SumoPlayer.isOutOfField(Side.Both))\r\n        basic.showIcon(IconNames.Sad)\r\n    else\r\n    if (SumoPlayer.isOutOfField(Side.Left))\r\n        basic.showArrow(ArrowNames.West)\r\n    else\r\n    if (SumoPlayer.isOutOfField(Side.Right))\r\n        basic.showArrow(ArrowNames.East)\r\n}\r\n"]]}]}]},{"timestamp":1758448949616,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11657,"length1":0,"diffs":[[1,"basic.showIcon(IconNames.Happy)\r\n"]]},{"start1":11807,"length1":34,"diffs":[[1,"    let fielddiameter = 100 // cm\r\n"]]},{"start1":13489,"length1":0,"diffs":[[1,"        let tm = control.millis() + 5000\r\n"]]},{"start1":13793,"length1":27,"diffs":[[1,"        } while (cm > 20 && control.millis() < tm)\r\n"]]},{"start1":14049,"length1":151,"diffs":[[1,"        while (CutebotPro.readDistance() > fielddiameter) { }\r\n"]]},{"start1":16228,"length1":132,"diffs":[[1,"    \r\n})"]]}]}]},{"timestamp":1758449512032,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":13187,"length1":52,"diffs":[[1,"        let cm = CutebotPro.readDistance()\r\n        if (cm > 20) return\r\n"]]},{"start1":13598,"length1":49,"diffs":[[1,"            if (cm > fielddiameter) {\r\n                CutebotPro.speed(0, 0)\r\n                return;\r\n            }\r\n        } while (cm > 20)\r\n"]]},{"start1":16184,"length1":33,"diffs":[[1,"    SumoPlayer.findOpponent()\r\n"]]}]}]},{"timestamp":1758450095755,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":13187,"length1":52,"diffs":[[1,"        if (CutebotPro.readDistance() > 12) return\r\n"]]},{"start1":13577,"length1":29,"diffs":[[1,""]]},{"start1":16231,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1758450664138,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":15610,"length1":58,"diffs":[[1,"            if (showPlayerHandler) showPlayerHandler()\r\n"]]},{"start1":15734,"length1":56,"diffs":[[1,"            CutebotPro.ledColor(Led.Both, Color.Black)\r\n"]]},{"start1":15830,"length1":30,"diffs":[[1,"            basic.pause(230)\r\n"]]},{"start1":16095,"length1":24,"diffs":[[1,"//    SumoPlayer.findOpponent()\r\n    SumoPlayer.runToOpponent()\r\n    SumoPlayer.pushOpponent()\r\n    General.wait(1)\r\n    SumoPlayer.stop()\r\n"]]}]}]},{"timestamp":1758451259655,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":14724,"length1":56,"diffs":[[1,"        for (let speed = 10; speed < 50; speed += 5) {\r\n"]]},{"start1":14801,"length1":62,"diffs":[[1,"                CutebotPro.ledColor(Led.Both, Color.Black)\r\n"]]},{"start1":15006,"length1":30,"diffs":[[1,"            basic.pause(200)\r\n"]]},{"start1":15047,"length1":56,"diffs":[[1,"        for (let speed = 50; speed >= 0; speed -= 5) {\r\n"]]},{"start1":15124,"length1":62,"diffs":[[1,"                CutebotPro.ledColor(Led.Both, Color.Black)\r\n"]]},{"start1":15329,"length1":30,"diffs":[[1,"            basic.pause(200)\r\n"]]},{"start1":15832,"length1":30,"diffs":[[1,"            basic.pause(225)\r\n"]]},{"start1":16041,"length1":28,"diffs":[[1,"MATCH = MatchStatus.Play\r\n"]]},{"start1":16097,"length1":26,"diffs":[[1,"    SumoPlayer.shake()\r\n"]]}]}]},{"timestamp":1758451859031,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":14461,"length1":33,"diffs":[[1,"    export function turnLedsOff() {\r\n"]]},{"start1":15008,"length1":30,"diffs":[[1,"            basic.pause(180)\r\n"]]},{"start1":15333,"length1":30,"diffs":[[1,"            basic.pause(180)\r\n"]]}]}]},{"timestamp":1758452425221,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":16099,"length1":181,"diffs":[[1,"    SumoPlayer.tornado()\r\n"]]}]}]},{"timestamp":1758452975642,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":15967,"length1":0,"diffs":[[1,"\r\n\r\n\r\n////////////////////\r\n// TEST-PROGRAMMA //\r\n////////////////////\r\n\r\n//MATCH = MatchStatus.Play\r\n\r\nbasic.forever(function() {\r\n    SumoPlayer.move(Move.Forward, Bend.None)\r\n    General.wait(1)\r\n    SumoPlayer.stop()\r\n    SumoPlayer.move(Move.Backward, Bend.None)\r\n    General.wait(1)\r\n    SumoPlayer.stop()\r\n    General.wait(5)\r\n})\r\n\r\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":27,"diffs":[[1,"    \"name\": \"test-sumo\",\n"]]},{"start1":398,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests gaan hier; deze zal niet worden gecompileerd wanneer dit pakket wordt gebruikt als extensie.\n"}]}],"snapshots":[{"timestamp":1758398178307,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1758405148359,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:ETmbit/general#50a144080fdbd8fb9bbefaa9a369108262fa31d4\",\n        \"match\": \"github:ETmbit/match#191656141aa933f8a0672849baaa5e4ad64b18fa\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1758441424391,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"////////////////////\r\n//################//\r\n//##            ##//\r\n//##  track.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum TrackType {\r\n    //% block=\"black on white\"\r\n    //% block.loc.nl=\"zwart op wit\"\r\n    BlackOnWhite,\r\n    //% block=\"white on black\"\r\n    //% block.loc.nl=\"wit op zwart\"\r\n    WhiteOnBlack,\r\n}\r\n\r\nenum TrackMask {\r\n    //% block=\"two sensors\"\r\n    //% block.loc.nl=\"twee sensoren\"\r\n    Track2 = 10,\r\n    //% block=\"three sensors\"\r\n    //% block.loc.nl=\"drie sensoren\"\r\n    Track3 = 14,\r\n    //% block=\"four sensors\"\r\n    //% block.loc.nl=\"vier sensoren\"\r\n    Track4 = 27,\r\n    //% block=\"five sensors\"\r\n    //% block.loc.nl=\"vijf sensoren\"\r\n    Track5 = 31,\r\n}\r\n\r\nenum Track {\r\n    //% block=\"off the track\"\r\n    //% block.loc.nl=\"van de lijn af\"\r\n    OffTrack = 0,\r\n    //% block=\"the track at far left\"\r\n    //% block.loc.nl=\"de lijn op uiterst links\"\r\n    FarLeft = 1,\r\n    //% block=\"the track at left\"\r\n    //% block.loc.nl=\"de lijn op links\"\r\n    Left = 2,\r\n    //% block=\"on the track\"\r\n    //% block.loc.nl=\"op de lijn\"\r\n    Mid = 4,\r\n    //% block=\"the track at right\"\r\n    //% block.loc.nl=\"de lijn op rechts\"\r\n    Right = 8,\r\n    //% block=\"the track at far right\"\r\n    //% block.loc.nl=\"de lijn op uiterst rechts\"\r\n    FarRight = 16,\r\n}\r\n\r\nfunction trackPosition(track: number, mask = TrackMask.Track2, tracktype = TrackType.BlackOnWhite): Track {\r\n    if (tracktype == TrackType.WhiteOnBlack) track = ~track\r\n    track = (track & mask)\r\n\r\n    if (!track)\r\n        return Track.OffTrack\r\n    if (track & 17) { // extreme left or right sensor\r\n        if (track & 4) { // mid sensor too\r\n            if (track & 1) return Track.Left\r\n            if (track & 16) return Track.Right\r\n        }\r\n        else { // whitout mid sensor\r\n            if (track & 1) return Track.FarLeft\r\n            if (track & 16) return Track.FarRight\r\n        }\r\n    }\r\n    if (((track & 10) == 10) ||   // both left and right sensor\r\n        ((track & 4) == track)) // mid sensor only\r\n        return Track.Mid\r\n    if (track & 2)\r\n        return Track.Left\r\n    if (track & 8)\r\n        return Track.Right\r\n    return Track.OffTrack\r\n}\r\n\r\n\r\n////////////////////\r\n//################//\r\n//##            ##//\r\n//##  servo.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum ServoType {\r\n    Continuous = 0,\r\n    ST90 = 90,\r\n    ST180 = 180,\r\n    ST270 = 270,\r\n    ST360 = 360,\r\n}\r\n\r\nnamespace Servo {\r\n\r\n    export class Device {\r\n\r\n        pin: AnalogPin\r\n        servo: ServoType\r\n        minpw: number = 1000\r\n        maxpw: number = 2000\r\n\r\n        constructor(_pin: AnalogPin, _type: ServoType) {\r\n            this.pin = _pin\r\n            this.servo = _type\r\n        }\r\n\r\n        setPulse(_min: number, _max: number) {\r\n            this.minpw = _min;\r\n            this.maxpw = _max;\r\n        }\r\n\r\n        angle(_angle: number) {\r\n            _angle = Math.map(_angle, this.minpw, this.maxpw, 0, this.servo)\r\n            pins.servoSetPulse(this.pin, _angle)\r\n            //pins.servoWritePin(this.pin, _angle)\r\n        }\r\n\r\n        speed(_speed: number) {\r\n            _speed = Math.map(_speed, this.minpw, this.maxpw, -100, 100)\r\n            pins.servoSetPulse(this.pin, _speed)\r\n        }\r\n    }\r\n\r\n    export function create(_pin: AnalogPin, _type: ServoType): Device {\r\n        let device = new Device(_pin, _type)\r\n        return device\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////\r\n//#####################//\r\n//##                 ##//\r\n//##  cutebotpro.ts  ##//\r\n//##                 ##//\r\n//#####################//\r\n/////////////////////////\r\n\r\nenum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n}\r\n\r\nenum ServoPort {\r\n    S1,\r\n    S2,\r\n    S3,\r\n    S4,\r\n}\r\n\r\nenum GpioPort {\r\n    G1,\r\n    G2,\r\n    G3,\r\n    G4,\r\n}\r\n\r\nnamespace CutebotPro {\r\n    // supports CutebotPro V2\r\n\r\n    const cutebotProAddr = 0x10\r\n\r\n    let trackType = TrackType.BlackOnWhite\r\n\r\n    let AnalogGP = [AnalogPin.P1, AnalogPin.P2, AnalogPin.P13, AnalogPin.P14]\r\n    let DigitalGP = [DigitalPin.P1, DigitalPin.P2, DigitalPin.P13, DigitalPin.P14]\r\n\r\n    function delay_ms(ms: number) {\r\n        let endTime = input.runningTime() + ms;\r\n        while (endTime > input.runningTime()) { }\r\n    }\r\n\r\n    export function pid_delay_ms(ms: number) {\r\n        let time = control.millis() + ms\r\n        while (1) {\r\n            i2cCommandSend(0xA0, [0x05])\r\n            if (pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false) || control.millis() >= time) {\r\n                basic.pause(500)\r\n                break\r\n            }\r\n            basic.pause(10)\r\n        }\r\n    }\r\n\r\n    export function i2cCommandSend(command: number, params: number[]) {\r\n        let buff = pins.createBuffer(params.length + 4);\r\n        buff[0] = 0xFF;\r\n        buff[1] = 0xF9;\r\n        buff[2] = command;\r\n        buff[3] = params.length;\r\n        for (let i = 0; i < params.length; i++) {\r\n            buff[i + 4] = params[i];\r\n        }\r\n        pins.i2cWriteBuffer(cutebotProAddr, buff);\r\n        delay_ms(1);\r\n    }\r\n\r\n    // MOTION MODULE\r\n\r\n    export function speed(left: number, right: number): void {\r\n        // speed in % [-100, 100]\r\n\r\n        let direction: number = 0;\r\n        if (left < 0) direction |= 0x01;\r\n        if (right < 0) direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(left), Math.abs(right), direction]);\r\n    }\r\n\r\n    export function move(speed: number, distance: number): void {\r\n        // speed in % [-100, -40] backward and [40, 100] forward\r\n        // distance in cm [0, 6000]\r\n\r\n        distance = ((distance > 6000 ? 6000 : distance) < 0 ? 0 : distance);\r\n        distance *= 10 // cm to mm\r\n        let distance_h = distance >> 8;\r\n        let distance_l = distance & 0xFF;\r\n\r\n        let direction2: number\r\n        if (speed <= 0) {\r\n            speed = -speed\r\n            direction2 = 3\r\n        } else\r\n            direction2 = 0\r\n\r\n        speed *= 5 // % to mm/s\r\n        speed = ((speed > 500 ? 500 : speed) < 200 ? 200 : speed);\r\n        let speed_h = speed >> 8;\r\n        let speed_l = speed & 0xFF;\r\n\r\n        i2cCommandSend(0x84, [distance_h, distance_l, speed_h, speed_l, direction2]);\r\n        pid_delay_ms(Math.round(distance * 1.0 / 1000 * 8000 + 3000))\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function motor(speed: number): void {\r\n        let direction: number = (speed > 0 ? 1 : 0)\r\n        i2cCommandSend(0x30, [Math.abs(speed), direction])\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    export function servoAngle(port: ServoPort, angle: number, _type: ServoType = ServoType.ST180) {\r\n        angle = Math.map(angle, 0, _type, 0, 180)\r\n        i2cCommandSend(0x40, [port, angle])\r\n    }\r\n\r\n    export function servoSpeed(port: ServoPort, speed: number) {\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        i2cCommandSend(0x40, [port, speed])\r\n    }\r\n\r\n    // LED MODULE\r\n\r\n    export function ledColor(led: Led, color: Color): void {\r\n        let rgbval = fromColor(color)\r\n        let red = (rgbval >> 16) & 0xFF;\r\n        let green = (rgbval >> 8) & 0xFF;\r\n        let blue = (rgbval) & 0xFF;\r\n        i2cCommandSend(0x20, [led, red, green, blue]);\r\n    }\r\n\r\n    // TRACKING MODULE\r\n\r\n    export function setTrackType(_type: TrackType) {\r\n        trackType = _type\r\n    }\r\n\r\n    export function readTrack(): Track {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = (state & 3) + ((state & 12) << 1)\r\n        track = trackPosition(track, TrackMask.Track4, trackType)\r\n        return track\r\n    }\r\n\r\n    export function isTrackAtLeft(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Left || track == Track.FarLeft)\r\n    }\r\n\r\n    export function isTrackAtRight(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Right || track == Track.FarRight)\r\n    }\r\n\r\n    export function isOnTrack(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Mid)\r\n    }\r\n\r\n    export function isOffTrack(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.OffTrack)\r\n    }\r\n\r\n    // DISTANCE MODULE\r\n\r\n    export function readDistance(): number {\r\n        // send pulse\r\n\r\n        pins.setPull(DigitalPin.P8, PinPullMode.PullNone);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(DigitalPin.P8, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n\r\n        // read pulse\r\n\r\n        // the next code is replacing the original since\r\n        // driving the motors causes interference with pulseIn\r\n\r\n        while (!pins.digitalReadPin(DigitalPin.P12)) { }\r\n        let tm1 = input.runningTimeMicros()\r\n        while (pins.digitalReadPin(DigitalPin.P12)) {\r\n            if (input.runningTimeMicros() - tm1 > 7288)\r\n                return 999 // timeout at further than 250 cm\r\n        }\r\n        let tm2 = input.runningTimeMicros()\r\n        let dist = (tm2 - tm1) * 343 / 20000\r\n        return Math.floor(dist)\r\n    }\r\n\r\n    // GPIO MODULE\r\n\r\n    export function analogPin(port: GpioPort): AnalogPin {\r\n        return AnalogGP[port]\r\n    }\r\n\r\n    export function digitalPin(port: GpioPort): DigitalPin {\r\n        return DigitalGP[port]\r\n    }\r\n\r\n}\r\n\r\n\r\n//////////////////////////\r\n//######################//\r\n//##                  ##//\r\n//##  sumo-player.ts  ##//\r\n//##                  ##//\r\n//######################//\r\n//////////////////////////\r\n\r\nlet ROLE = Player.Green\r\n\r\nenum Bend {\r\n    //% block=\"go straight\"\r\n    //% block.loc.nl=\"ga rechtdoor\"\r\n    None,\r\n    //% block=\"turn to the left\"\r\n    //% block.loc.nl=\"draai naar links\"\r\n    Left,\r\n    //% block=\"turn to the right\"\r\n    //% block.loc.nl=\"draai naar rechts\"\r\n    Right\r\n}\r\n\r\nenum Side {\r\n    //% block=\"both sides\"\r\n    //% block.loc.nl=\"beide kanten\"\r\n    Both,\r\n    //% block=\"the left side\"\r\n    //% block.loc.nl=\"de linker kant\"\r\n    Left,\r\n    //% block=\"the right side\"\r\n    //% block.loc.nl=\"de rechter kant\"\r\n    Right\r\n}\r\n\r\n// setPlayerHandler is called from match.ts\r\nsetPlayerHandler = (player: Player) => {\r\n    ROLE = player\r\n}\r\n\r\n// showPlayerHandler is called from match.ts and this extension\r\nshowPlayerHandler = () => {\r\n    if (ROLE == Player.Green)\r\n        CutebotPro.ledColor(Led.Both, Color.Green)\r\n    else\r\n        CutebotPro.ledColor(Led.Both, Color.Blue)\r\n}\r\n\r\nresetHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nstopHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nif (initPlayerHandler) initPlayerHandler()\r\nif (displayHandler) displayHandler()\r\n\r\nbasic.forever(function () {\r\n    if (isPlaying && !isPlaying()) return\r\n    if (CutebotPro.readTrack() != Track.OffTrack) {\r\n        CutebotPro.ledColor(Led.Both, Color.Red)\r\n    }\r\n    else {\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n})\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Sumo\"\r\n//% block.loc.nl=\"Sumo\"\r\nnamespace SumoPlayer {\r\n\r\n    //% subcategory=\"Bewegen\"\r\n    //% block=\"stop\"\r\n    //% block.loc.nl=\"stop\"\r\n    export function stop() {\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"when %side is out of the field\"\r\n    //% block.loc.nl=\"wanneer %side buiten het speelveld is\"\r\n    export function onEventLeftOutOfField(side: Side, programmableCode: () => void): void {\r\n        switch (side) {\r\n            case Side.Both: EventBothOutOfField = programmableCode; break;\r\n            case Side.Left: EventLeftOutOfField = programmableCode; break;\r\n            case Side.Right: EventRightOutOfField = programmableCode; break;\r\n        }\r\n    }\r\n\r\n\r\n    //% block=\"move %dir and %bend\"\r\n    //% block.loc.nl=\"rijd %dir en %bend\"\r\n    export function move(dir: Move, bend: Bend) {\r\n        let speed: number\r\n        if (dir == Move.Forward) speed = 20\r\n        else speed = -20\r\n        switch (bend) {\r\n            case Bend.None: Cutebot.setSpeed(speed, speed); break;\r\n            case Bend.Left: Cutebot.setSpeed(speed / 2, speed); break;\r\n            case Bend.Right: Cutebot.setSpeed(speed, speed / 2); break;\r\n        }\r\n    }\r\n\r\n    //% block=\"push the opponent\"\r\n    //% block.loc.nl=\"duw de tegenstander\"\r\n    export function pushOpponent() {\r\n        let cm = Cutebot.readDistance()\r\n        if (cm > 20) return\r\n        Cutebot.setSpeed(100, 100)\r\n    }\r\n\r\n    //% block=\"the opponent is close\"\r\n    //% block.loc.nl=\"de tegenstander dichtbij is\"\r\n    export function nearOpponent(): boolean {\r\n        let val = NEAR\r\n        NEAR = false\r\n        return val\r\n    }\r\n\r\n    //% block=\"run to the opponent\"\r\n    //% block.loc.nl=\"rijd naar de tegenstander\"\r\n    export function runToOpponent() {\r\n        NEAR = false\r\n        let cm = Cutebot.readDistance()\r\n        if (cm > DIAMETER) return\r\n        let tm = input.runningTime() + cm * 1000 / 25\r\n        Cutebot.setSpeed(20, 20)\r\n        do {\r\n            cm = Cutebot.readDistance()\r\n            if (cm > DIAMETER) {\r\n                Cutebot.setSpeed(0, 0)\r\n                return;\r\n            }\r\n        } while (cm > 20 && input.runningTime() < tm)\r\n        Cutebot.setSpeed(0, 0)\r\n        NEAR = true\r\n    }\r\n\r\n    //% block=\"turn to the opponent\"\r\n    //% block.loc.nl=\"draai richting tegenstander\"\r\n    export function findOpponent() {\r\n        Cutebot.setSpeed(-15, 15)\r\n        while (Cutebot.readDistance() > DIAMETER) { }\r\n        Cutebot.setSpeed(0, 0)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn %led color %color\"\r\n    //% block.loc.nl=\"kleur %led %color\"\r\n    //% color.defl=Color.White\r\n    export function showColor(led: Led, color: Color) {\r\n        Cutebot.ledColor(led, color)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn both leds off\"\r\n    //% block.loc.nl=\"schakel beide leds uit\"\r\n    export function turnLedsOff() {\r\n        Cutebot.ledColor(Led.Both, Color.None)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"tornado\"\r\n    //% block.loc.nl=\"tornado\"\r\n    export function tornado() {\r\n        let on = true\r\n        for (let speed = 10; speed < 50; speed += 5) {\r\n            if (on) {\r\n                LEDS.setClear()\r\n                LEDS.show()\r\n            }\r\n            else {\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            }\r\n            on = !on\r\n            NezhaBrick.twoWheelSpeed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        for (let speed = 50; speed >= 0; speed -= 5) {\r\n            if (on) {\r\n                LEDS.setClear()\r\n                LEDS.show()\r\n            }\r\n            else {\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            }\r\n            on = !on\r\n            NezhaBrick.twoWheelSpeed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"shake\"\r\n    //% block.loc.nl=\"schudden\"\r\n    export function shake() {\r\n        for (let i = 0; i < 6; i++) {\r\n            NezhaBrick.twoWheelSpeed(30, 30)\r\n            basic.pause(200)\r\n            LEDS.setClear()\r\n            LEDS.show()\r\n            NezhaBrick.twoWheelSpeed(-30, -30)\r\n            basic.pause(230)\r\n        }\r\n        NezhaBrick.twoWheelSpeed(0, 0)\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:ETmbit/general#50a144080fdbd8fb9bbefaa9a369108262fa31d4\",\n        \"match\": \"github:ETmbit/match#191656141aa933f8a0672849baaa5e4ad64b18fa\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1758443225557,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"////////////////////\r\n//################//\r\n//##            ##//\r\n//##  track.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum TrackType {\r\n    //% block=\"black on white\"\r\n    //% block.loc.nl=\"zwart op wit\"\r\n    BlackOnWhite,\r\n    //% block=\"white on black\"\r\n    //% block.loc.nl=\"wit op zwart\"\r\n    WhiteOnBlack,\r\n}\r\n\r\nenum TrackMask {\r\n    //% block=\"two sensors\"\r\n    //% block.loc.nl=\"twee sensoren\"\r\n    Track2 = 10,\r\n    //% block=\"three sensors\"\r\n    //% block.loc.nl=\"drie sensoren\"\r\n    Track3 = 14,\r\n    //% block=\"four sensors\"\r\n    //% block.loc.nl=\"vier sensoren\"\r\n    Track4 = 27,\r\n    //% block=\"five sensors\"\r\n    //% block.loc.nl=\"vijf sensoren\"\r\n    Track5 = 31,\r\n}\r\n\r\nenum Track {\r\n    //% block=\"off the track\"\r\n    //% block.loc.nl=\"van de lijn af\"\r\n    OffTrack = 0,\r\n    //% block=\"the track at far left\"\r\n    //% block.loc.nl=\"de lijn op uiterst links\"\r\n    FarLeft = 1,\r\n    //% block=\"the track at left\"\r\n    //% block.loc.nl=\"de lijn op links\"\r\n    Left = 2,\r\n    //% block=\"on the track\"\r\n    //% block.loc.nl=\"op de lijn\"\r\n    Mid = 4,\r\n    //% block=\"the track at right\"\r\n    //% block.loc.nl=\"de lijn op rechts\"\r\n    Right = 8,\r\n    //% block=\"the track at far right\"\r\n    //% block.loc.nl=\"de lijn op uiterst rechts\"\r\n    FarRight = 16,\r\n}\r\n\r\nfunction trackPosition(track: number, mask = TrackMask.Track2, tracktype = TrackType.BlackOnWhite): Track {\r\n    if (tracktype == TrackType.WhiteOnBlack) track = ~track\r\n    track = (track & mask)\r\n\r\n    if (!track)\r\n        return Track.OffTrack\r\n    if (track & 17) { // extreme left or right sensor\r\n        if (track & 4) { // mid sensor too\r\n            if (track & 1) return Track.Left\r\n            if (track & 16) return Track.Right\r\n        }\r\n        else { // whitout mid sensor\r\n            if (track & 1) return Track.FarLeft\r\n            if (track & 16) return Track.FarRight\r\n        }\r\n    }\r\n    if (((track & 10) == 10) ||   // both left and right sensor\r\n        ((track & 4) == track)) // mid sensor only\r\n        return Track.Mid\r\n    if (track & 2)\r\n        return Track.Left\r\n    if (track & 8)\r\n        return Track.Right\r\n    return Track.OffTrack\r\n}\r\n\r\n\r\n////////////////////\r\n//################//\r\n//##            ##//\r\n//##  servo.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum ServoType {\r\n    Continuous = 0,\r\n    ST90 = 90,\r\n    ST180 = 180,\r\n    ST270 = 270,\r\n    ST360 = 360,\r\n}\r\n\r\nnamespace Servo {\r\n\r\n    export class Device {\r\n\r\n        pin: AnalogPin\r\n        servo: ServoType\r\n        minpw: number = 1000\r\n        maxpw: number = 2000\r\n\r\n        constructor(_pin: AnalogPin, _type: ServoType) {\r\n            this.pin = _pin\r\n            this.servo = _type\r\n        }\r\n\r\n        setPulse(_min: number, _max: number) {\r\n            this.minpw = _min;\r\n            this.maxpw = _max;\r\n        }\r\n\r\n        angle(_angle: number) {\r\n            _angle = Math.map(_angle, this.minpw, this.maxpw, 0, this.servo)\r\n            pins.servoSetPulse(this.pin, _angle)\r\n            //pins.servoWritePin(this.pin, _angle)\r\n        }\r\n\r\n        speed(_speed: number) {\r\n            _speed = Math.map(_speed, this.minpw, this.maxpw, -100, 100)\r\n            pins.servoSetPulse(this.pin, _speed)\r\n        }\r\n    }\r\n\r\n    export function create(_pin: AnalogPin, _type: ServoType): Device {\r\n        let device = new Device(_pin, _type)\r\n        return device\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////\r\n//#####################//\r\n//##                 ##//\r\n//##  cutebotpro.ts  ##//\r\n//##                 ##//\r\n//#####################//\r\n/////////////////////////\r\n\r\nenum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n}\r\n\r\nenum ServoPort {\r\n    S1,\r\n    S2,\r\n    S3,\r\n    S4,\r\n}\r\n\r\nenum GpioPort {\r\n    G1,\r\n    G2,\r\n    G3,\r\n    G4,\r\n}\r\n\r\nnamespace CutebotPro {\r\n    // supports CutebotPro V2\r\n\r\n    const cutebotProAddr = 0x10\r\n\r\n    let trackType = TrackType.BlackOnWhite\r\n\r\n    let AnalogGP = [AnalogPin.P1, AnalogPin.P2, AnalogPin.P13, AnalogPin.P14]\r\n    let DigitalGP = [DigitalPin.P1, DigitalPin.P2, DigitalPin.P13, DigitalPin.P14]\r\n\r\n    function delay_ms(ms: number) {\r\n        let endTime = input.runningTime() + ms;\r\n        while (endTime > input.runningTime()) { }\r\n    }\r\n\r\n    export function pid_delay_ms(ms: number) {\r\n        let time = control.millis() + ms\r\n        while (1) {\r\n            i2cCommandSend(0xA0, [0x05])\r\n            if (pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false) || control.millis() >= time) {\r\n                basic.pause(500)\r\n                break\r\n            }\r\n            basic.pause(10)\r\n        }\r\n    }\r\n\r\n    export function i2cCommandSend(command: number, params: number[]) {\r\n        let buff = pins.createBuffer(params.length + 4);\r\n        buff[0] = 0xFF;\r\n        buff[1] = 0xF9;\r\n        buff[2] = command;\r\n        buff[3] = params.length;\r\n        for (let i = 0; i < params.length; i++) {\r\n            buff[i + 4] = params[i];\r\n        }\r\n        pins.i2cWriteBuffer(cutebotProAddr, buff);\r\n        delay_ms(1);\r\n    }\r\n\r\n    // MOTION MODULE\r\n\r\n    export function speed(left: number, right: number): void {\r\n        // speed in % [-100, 100]\r\n\r\n        let direction: number = 0;\r\n        if (left < 0) direction |= 0x01;\r\n        if (right < 0) direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(left), Math.abs(right), direction]);\r\n    }\r\n\r\n    export function move(speed: number, distance: number): void {\r\n        // speed in % [-100, -40] backward and [40, 100] forward\r\n        // distance in cm [0, 6000]\r\n\r\n        distance = ((distance > 6000 ? 6000 : distance) < 0 ? 0 : distance);\r\n        distance *= 10 // cm to mm\r\n        let distance_h = distance >> 8;\r\n        let distance_l = distance & 0xFF;\r\n\r\n        let direction2: number\r\n        if (speed <= 0) {\r\n            speed = -speed\r\n            direction2 = 3\r\n        } else\r\n            direction2 = 0\r\n\r\n        speed *= 5 // % to mm/s\r\n        speed = ((speed > 500 ? 500 : speed) < 200 ? 200 : speed);\r\n        let speed_h = speed >> 8;\r\n        let speed_l = speed & 0xFF;\r\n\r\n        i2cCommandSend(0x84, [distance_h, distance_l, speed_h, speed_l, direction2]);\r\n        pid_delay_ms(Math.round(distance * 1.0 / 1000 * 8000 + 3000))\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function motor(speed: number): void {\r\n        let direction: number = (speed > 0 ? 1 : 0)\r\n        i2cCommandSend(0x30, [Math.abs(speed), direction])\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    export function servoAngle(port: ServoPort, angle: number, _type: ServoType = ServoType.ST180) {\r\n        angle = Math.map(angle, 0, _type, 0, 180)\r\n        i2cCommandSend(0x40, [port, angle])\r\n    }\r\n\r\n    export function servoSpeed(port: ServoPort, speed: number) {\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        i2cCommandSend(0x40, [port, speed])\r\n    }\r\n\r\n    // LED MODULE\r\n\r\n    export function ledColor(led: Led, color: Color): void {\r\n        let rgbval = fromColor(color)\r\n        let red = (rgbval >> 16) & 0xFF;\r\n        let green = (rgbval >> 8) & 0xFF;\r\n        let blue = (rgbval) & 0xFF;\r\n        i2cCommandSend(0x20, [led, red, green, blue]);\r\n    }\r\n\r\n    // TRACKING MODULE\r\n\r\n    export function setTrackType(_type: TrackType) {\r\n        trackType = _type\r\n    }\r\n\r\n    export function readTrack(): Track {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = (state & 3) + ((state & 12) << 1)\r\n        track = trackPosition(track, TrackMask.Track4, trackType)\r\n        return track\r\n    }\r\n\r\n    export function isTrackAtLeft(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Left || track == Track.FarLeft)\r\n    }\r\n\r\n    export function isTrackAtRight(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Right || track == Track.FarRight)\r\n    }\r\n\r\n    export function isOnTrack(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Mid)\r\n    }\r\n\r\n    export function isOffTrack(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.OffTrack)\r\n    }\r\n\r\n    // DISTANCE MODULE\r\n\r\n    export function readDistance(): number {\r\n        // send pulse\r\n\r\n        pins.setPull(DigitalPin.P8, PinPullMode.PullNone);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(DigitalPin.P8, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n\r\n        // read pulse\r\n\r\n        // the next code is replacing the original since\r\n        // driving the motors causes interference with pulseIn\r\n\r\n        while (!pins.digitalReadPin(DigitalPin.P12)) { }\r\n        let tm1 = input.runningTimeMicros()\r\n        while (pins.digitalReadPin(DigitalPin.P12)) {\r\n            if (input.runningTimeMicros() - tm1 > 7288)\r\n                return 999 // timeout at further than 250 cm\r\n        }\r\n        let tm2 = input.runningTimeMicros()\r\n        let dist = (tm2 - tm1) * 343 / 20000\r\n        return Math.floor(dist)\r\n    }\r\n\r\n    // GPIO MODULE\r\n\r\n    export function analogPin(port: GpioPort): AnalogPin {\r\n        return AnalogGP[port]\r\n    }\r\n\r\n    export function digitalPin(port: GpioPort): DigitalPin {\r\n        return DigitalGP[port]\r\n    }\r\n\r\n}\r\n\r\n\r\n//////////////////////////\r\n//######################//\r\n//##                  ##//\r\n//##  sumo-player.ts  ##//\r\n//##                  ##//\r\n//######################//\r\n//////////////////////////\r\n\r\nlet ROLE = Player.Green\r\n\r\nenum Bend {\r\n    //% block=\"go straight\"\r\n    //% block.loc.nl=\"ga rechtdoor\"\r\n    None,\r\n    //% block=\"turn to the left\"\r\n    //% block.loc.nl=\"draai naar links\"\r\n    Left,\r\n    //% block=\"turn to the right\"\r\n    //% block.loc.nl=\"draai naar rechts\"\r\n    Right\r\n}\r\n\r\nenum Side {\r\n    //% block=\"both sides\"\r\n    //% block.loc.nl=\"beide kanten\"\r\n    Both,\r\n    //% block=\"the left side\"\r\n    //% block.loc.nl=\"de linker kant\"\r\n    Left,\r\n    //% block=\"the right side\"\r\n    //% block.loc.nl=\"de rechter kant\"\r\n    Right\r\n}\r\n\r\n// setPlayerHandler is called from match.ts\r\nsetPlayerHandler = (player: Player) => {\r\n    ROLE = player\r\n}\r\n\r\n// showPlayerHandler is called from match.ts and this extension\r\nshowPlayerHandler = () => {\r\n    if (ROLE == Player.Green)\r\n        CutebotPro.ledColor(Led.Both, Color.Green)\r\n    else\r\n        CutebotPro.ledColor(Led.Both, Color.Blue)\r\n}\r\n\r\nresetHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nstopHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nif (initPlayerHandler) initPlayerHandler()\r\nif (displayHandler) displayHandler()\r\n\r\nbasic.forever(function () {\r\n    if (isPlaying && !isPlaying()) return\r\n    if (CutebotPro.readTrack() != Track.OffTrack) {\r\n        CutebotPro.ledColor(Led.Both, Color.Red)\r\n    }\r\n    else {\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n})\r\n\r\nlet outOfFieldHandler: prmhandler\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Sumo\"\r\n//% block.loc.nl=\"Sumo\"\r\nnamespace SumoPlayer {\r\n\r\n    //% subcategory=\"Bewegen\"\r\n    //% block=\"stop\"\r\n    //% block.loc.nl=\"stop\"\r\n    export function stop() {\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"when %side is out of the field\"\r\n    //% block.loc.nl=\"wanneer %side buiten het speelveld is\"\r\n    export function onOutOfField(side: Side, code: (prm:number) => prmhandler) {\r\n        outOfFieldHandler = code(side)\r\n    }\r\n\r\n    //% block=\"move %dir and %bend\"\r\n    //% block.loc.nl=\"rijd %dir en %bend\"\r\n    export function move(dir: Move, bend: Bend) {\r\n        let speed: number\r\n        if (dir == Move.Forward) speed = 20\r\n        else speed = -20\r\n        switch (bend) {\r\n            case Bend.None: CutebotPro.setSpeed(speed, speed); break;\r\n            case Bend.Left: Cutebot.setSpeed(speed / 2, speed); break;\r\n            case Bend.Right: Cutebot.setSpeed(speed, speed / 2); break;\r\n        }\r\n    }\r\n\r\n    //% block=\"push the opponent\"\r\n    //% block.loc.nl=\"duw de tegenstander\"\r\n    export function pushOpponent() {\r\n        let cm = Cutebot.readDistance()\r\n        if (cm > 20) return\r\n        Cutebot.setSpeed(100, 100)\r\n    }\r\n\r\n    //% block=\"the opponent is close\"\r\n    //% block.loc.nl=\"de tegenstander dichtbij is\"\r\n    export function nearOpponent(): boolean {\r\n        let val = NEAR\r\n        NEAR = false\r\n        return val\r\n    }\r\n\r\n    //% block=\"run to the opponent\"\r\n    //% block.loc.nl=\"rijd naar de tegenstander\"\r\n    export function runToOpponent() {\r\n        NEAR = false\r\n        let cm = Cutebot.readDistance()\r\n        if (cm > DIAMETER) return\r\n        let tm = input.runningTime() + cm * 1000 / 25\r\n        Cutebot.setSpeed(20, 20)\r\n        do {\r\n            cm = Cutebot.readDistance()\r\n            if (cm > DIAMETER) {\r\n                Cutebot.setSpeed(0, 0)\r\n                return;\r\n            }\r\n        } while (cm > 20 && input.runningTime() < tm)\r\n        Cutebot.setSpeed(0, 0)\r\n        NEAR = true\r\n    }\r\n\r\n    //% block=\"turn to the opponent\"\r\n    //% block.loc.nl=\"draai richting tegenstander\"\r\n    export function findOpponent() {\r\n        Cutebot.setSpeed(-15, 15)\r\n        while (Cutebot.readDistance() > DIAMETER) { }\r\n        Cutebot.setSpeed(0, 0)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn %led color %color\"\r\n    //% block.loc.nl=\"kleur %led %color\"\r\n    //% color.defl=Color.White\r\n    export function showColor(led: Led, color: Color) {\r\n        Cutebot.ledColor(led, color)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn both leds off\"\r\n    //% block.loc.nl=\"schakel beide leds uit\"\r\n    export function turnLedsOff() {\r\n        Cutebot.ledColor(Led.Both, Color.None)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"tornado\"\r\n    //% block.loc.nl=\"tornado\"\r\n    export function tornado() {\r\n        let on = true\r\n        for (let speed = 10; speed < 50; speed += 5) {\r\n            if (on) {\r\n                LEDS.setClear()\r\n                LEDS.show()\r\n            }\r\n            else {\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            }\r\n            on = !on\r\n            NezhaBrick.twoWheelSpeed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        for (let speed = 50; speed >= 0; speed -= 5) {\r\n            if (on) {\r\n                LEDS.setClear()\r\n                LEDS.show()\r\n            }\r\n            else {\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            }\r\n            on = !on\r\n            NezhaBrick.twoWheelSpeed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"shake\"\r\n    //% block.loc.nl=\"schudden\"\r\n    export function shake() {\r\n        for (let i = 0; i < 6; i++) {\r\n            NezhaBrick.twoWheelSpeed(30, 30)\r\n            basic.pause(200)\r\n            LEDS.setClear()\r\n            LEDS.show()\r\n            NezhaBrick.twoWheelSpeed(-30, -30)\r\n            basic.pause(230)\r\n        }\r\n        NezhaBrick.twoWheelSpeed(0, 0)\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:ETmbit/general#50a144080fdbd8fb9bbefaa9a369108262fa31d4\",\n        \"match\": \"github:ETmbit/match#191656141aa933f8a0672849baaa5e4ad64b18fa\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1758445636386,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"////////////////////\r\n//################//\r\n//##            ##//\r\n//##  track.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum TrackType {\r\n    //% block=\"black on white\"\r\n    //% block.loc.nl=\"zwart op wit\"\r\n    BlackOnWhite,\r\n    //% block=\"white on black\"\r\n    //% block.loc.nl=\"wit op zwart\"\r\n    WhiteOnBlack,\r\n}\r\n\r\nenum TrackMask {\r\n    //% block=\"two sensors\"\r\n    //% block.loc.nl=\"twee sensoren\"\r\n    Track2 = 10,\r\n    //% block=\"three sensors\"\r\n    //% block.loc.nl=\"drie sensoren\"\r\n    Track3 = 14,\r\n    //% block=\"four sensors\"\r\n    //% block.loc.nl=\"vier sensoren\"\r\n    Track4 = 27,\r\n    //% block=\"five sensors\"\r\n    //% block.loc.nl=\"vijf sensoren\"\r\n    Track5 = 31,\r\n}\r\n\r\nenum Track {\r\n    //% block=\"off the track\"\r\n    //% block.loc.nl=\"van de lijn af\"\r\n    OffTrack = 0,\r\n    //% block=\"the track at far left\"\r\n    //% block.loc.nl=\"de lijn op uiterst links\"\r\n    FarLeft = 1,\r\n    //% block=\"the track at left\"\r\n    //% block.loc.nl=\"de lijn op links\"\r\n    Left = 2,\r\n    //% block=\"on the track\"\r\n    //% block.loc.nl=\"op de lijn\"\r\n    Mid = 4,\r\n    //% block=\"the track at right\"\r\n    //% block.loc.nl=\"de lijn op rechts\"\r\n    Right = 8,\r\n    //% block=\"the track at far right\"\r\n    //% block.loc.nl=\"de lijn op uiterst rechts\"\r\n    FarRight = 16,\r\n}\r\n\r\nfunction trackPosition(track: number, mask = TrackMask.Track2, tracktype = TrackType.BlackOnWhite): Track {\r\n    if (tracktype == TrackType.WhiteOnBlack) track = ~track\r\n    track = (track & mask)\r\n\r\n    if (!track)\r\n        return Track.OffTrack\r\n    if (track & 17) { // extreme left or right sensor\r\n        if (track & 4) { // mid sensor too\r\n            if (track & 1) return Track.Left\r\n            if (track & 16) return Track.Right\r\n        }\r\n        else { // whitout mid sensor\r\n            if (track & 1) return Track.FarLeft\r\n            if (track & 16) return Track.FarRight\r\n        }\r\n    }\r\n    if (((track & 10) == 10) ||   // both left and right sensor\r\n        ((track & 4) == track)) // mid sensor only\r\n        return Track.Mid\r\n    if (track & 2)\r\n        return Track.Left\r\n    if (track & 8)\r\n        return Track.Right\r\n    return Track.OffTrack\r\n}\r\n\r\n\r\n////////////////////\r\n//################//\r\n//##            ##//\r\n//##  servo.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum ServoType {\r\n    Continuous = 0,\r\n    ST90 = 90,\r\n    ST180 = 180,\r\n    ST270 = 270,\r\n    ST360 = 360,\r\n}\r\n\r\nnamespace Servo {\r\n\r\n    export class Device {\r\n\r\n        pin: AnalogPin\r\n        servo: ServoType\r\n        minpw: number = 1000\r\n        maxpw: number = 2000\r\n\r\n        constructor(_pin: AnalogPin, _type: ServoType) {\r\n            this.pin = _pin\r\n            this.servo = _type\r\n        }\r\n\r\n        setPulse(_min: number, _max: number) {\r\n            this.minpw = _min;\r\n            this.maxpw = _max;\r\n        }\r\n\r\n        angle(_angle: number) {\r\n            _angle = Math.map(_angle, this.minpw, this.maxpw, 0, this.servo)\r\n            pins.servoSetPulse(this.pin, _angle)\r\n            //pins.servoWritePin(this.pin, _angle)\r\n        }\r\n\r\n        speed(_speed: number) {\r\n            _speed = Math.map(_speed, this.minpw, this.maxpw, -100, 100)\r\n            pins.servoSetPulse(this.pin, _speed)\r\n        }\r\n    }\r\n\r\n    export function create(_pin: AnalogPin, _type: ServoType): Device {\r\n        let device = new Device(_pin, _type)\r\n        return device\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////\r\n//#####################//\r\n//##                 ##//\r\n//##  cutebotpro.ts  ##//\r\n//##                 ##//\r\n//#####################//\r\n/////////////////////////\r\n\r\nenum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n}\r\n\r\nenum ServoPort {\r\n    S1,\r\n    S2,\r\n    S3,\r\n    S4,\r\n}\r\n\r\nenum GpioPort {\r\n    G1,\r\n    G2,\r\n    G3,\r\n    G4,\r\n}\r\n\r\nnamespace CutebotPro {\r\n    // supports CutebotPro V2\r\n\r\n    const cutebotProAddr = 0x10\r\n\r\n    let trackType = TrackType.BlackOnWhite\r\n\r\n    let AnalogGP = [AnalogPin.P1, AnalogPin.P2, AnalogPin.P13, AnalogPin.P14]\r\n    let DigitalGP = [DigitalPin.P1, DigitalPin.P2, DigitalPin.P13, DigitalPin.P14]\r\n\r\n    function delay_ms(ms: number) {\r\n        let endTime = input.runningTime() + ms;\r\n        while (endTime > input.runningTime()) { }\r\n    }\r\n\r\n    export function pid_delay_ms(ms: number) {\r\n        let time = control.millis() + ms\r\n        while (1) {\r\n            i2cCommandSend(0xA0, [0x05])\r\n            if (pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false) || control.millis() >= time) {\r\n                basic.pause(500)\r\n                break\r\n            }\r\n            basic.pause(10)\r\n        }\r\n    }\r\n\r\n    export function i2cCommandSend(command: number, params: number[]) {\r\n        let buff = pins.createBuffer(params.length + 4);\r\n        buff[0] = 0xFF;\r\n        buff[1] = 0xF9;\r\n        buff[2] = command;\r\n        buff[3] = params.length;\r\n        for (let i = 0; i < params.length; i++) {\r\n            buff[i + 4] = params[i];\r\n        }\r\n        pins.i2cWriteBuffer(cutebotProAddr, buff);\r\n        delay_ms(1);\r\n    }\r\n\r\n    // MOTION MODULE\r\n\r\n    export function speed(left: number, right: number): void {\r\n        // speed in % [-100, 100]\r\n\r\n        let direction: number = 0;\r\n        if (left < 0) direction |= 0x01;\r\n        if (right < 0) direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(left), Math.abs(right), direction]);\r\n    }\r\n\r\n    export function move(speed: number, distance: number): void {\r\n        // speed in % [-100, -40] backward and [40, 100] forward\r\n        // distance in cm [0, 6000]\r\n\r\n        distance = ((distance > 6000 ? 6000 : distance) < 0 ? 0 : distance);\r\n        distance *= 10 // cm to mm\r\n        let distance_h = distance >> 8;\r\n        let distance_l = distance & 0xFF;\r\n\r\n        let direction2: number\r\n        if (speed <= 0) {\r\n            speed = -speed\r\n            direction2 = 3\r\n        } else\r\n            direction2 = 0\r\n\r\n        speed *= 5 // % to mm/s\r\n        speed = ((speed > 500 ? 500 : speed) < 200 ? 200 : speed);\r\n        let speed_h = speed >> 8;\r\n        let speed_l = speed & 0xFF;\r\n\r\n        i2cCommandSend(0x84, [distance_h, distance_l, speed_h, speed_l, direction2]);\r\n        pid_delay_ms(Math.round(distance * 1.0 / 1000 * 8000 + 3000))\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function motor(speed: number): void {\r\n        let direction: number = (speed > 0 ? 1 : 0)\r\n        i2cCommandSend(0x30, [Math.abs(speed), direction])\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    export function servoAngle(port: ServoPort, angle: number, _type: ServoType = ServoType.ST180) {\r\n        angle = Math.map(angle, 0, _type, 0, 180)\r\n        i2cCommandSend(0x40, [port, angle])\r\n    }\r\n\r\n    export function servoSpeed(port: ServoPort, speed: number) {\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        i2cCommandSend(0x40, [port, speed])\r\n    }\r\n\r\n    // LED MODULE\r\n\r\n    export function ledColor(led: Led, color: Color): void {\r\n        let rgbval = fromColor(color)\r\n        let red = (rgbval >> 16) & 0xFF;\r\n        let green = (rgbval >> 8) & 0xFF;\r\n        let blue = (rgbval) & 0xFF;\r\n        i2cCommandSend(0x20, [led, red, green, blue]);\r\n    }\r\n\r\n    // TRACKING MODULE\r\n\r\n    export function setTrackType(_type: TrackType) {\r\n        trackType = _type\r\n    }\r\n\r\n    export function readTrack(): Track {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = (state & 3) + ((state & 12) << 1)\r\n        track = trackPosition(track, TrackMask.Track4, trackType)\r\n        return track\r\n    }\r\n\r\n    export function isTrackAtLeft(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Left || track == Track.FarLeft)\r\n    }\r\n\r\n    export function isTrackAtRight(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Right || track == Track.FarRight)\r\n    }\r\n\r\n    export function isOnTrack(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Mid)\r\n    }\r\n\r\n    export function isOffTrack(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.OffTrack)\r\n    }\r\n\r\n    // DISTANCE MODULE\r\n\r\n    export function readDistance(): number {\r\n        // send pulse\r\n\r\n        pins.setPull(DigitalPin.P8, PinPullMode.PullNone);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(DigitalPin.P8, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n\r\n        // read pulse\r\n\r\n        // the next code is replacing the original since\r\n        // driving the motors causes interference with pulseIn\r\n\r\n        while (!pins.digitalReadPin(DigitalPin.P12)) { }\r\n        let tm1 = input.runningTimeMicros()\r\n        while (pins.digitalReadPin(DigitalPin.P12)) {\r\n            if (input.runningTimeMicros() - tm1 > 7288)\r\n                return 999 // timeout at further than 250 cm\r\n        }\r\n        let tm2 = input.runningTimeMicros()\r\n        let dist = (tm2 - tm1) * 343 / 20000\r\n        return Math.floor(dist)\r\n    }\r\n\r\n    // GPIO MODULE\r\n\r\n    export function analogPin(port: GpioPort): AnalogPin {\r\n        return AnalogGP[port]\r\n    }\r\n\r\n    export function digitalPin(port: GpioPort): DigitalPin {\r\n        return DigitalGP[port]\r\n    }\r\n\r\n}\r\n\r\n\r\n//////////////////////////\r\n//######################//\r\n//##                  ##//\r\n//##  sumo-player.ts  ##//\r\n//##                  ##//\r\n//######################//\r\n//////////////////////////\r\n\r\nlet ROLE = Player.Green\r\n\r\nenum Bend {\r\n    //% block=\"go straight\"\r\n    //% block.loc.nl=\"ga rechtdoor\"\r\n    None,\r\n    //% block=\"turn to the left\"\r\n    //% block.loc.nl=\"draai naar links\"\r\n    Left,\r\n    //% block=\"turn to the right\"\r\n    //% block.loc.nl=\"draai naar rechts\"\r\n    Right\r\n}\r\n\r\nenum Side {\r\n    //% block=\"both sides\"\r\n    //% block.loc.nl=\"beide kanten\"\r\n    Both,\r\n    //% block=\"the left side\"\r\n    //% block.loc.nl=\"de linker kant\"\r\n    Left,\r\n    //% block=\"the right side\"\r\n    //% block.loc.nl=\"de rechter kant\"\r\n    Right\r\n}\r\n\r\n// setPlayerHandler is called from match.ts\r\nsetPlayerHandler = (player: Player) => {\r\n    ROLE = player\r\n}\r\n\r\n// showPlayerHandler is called from match.ts and this extension\r\nshowPlayerHandler = () => {\r\n    if (ROLE == Player.Green)\r\n        CutebotPro.ledColor(Led.Both, Color.Green)\r\n    else\r\n        CutebotPro.ledColor(Led.Both, Color.Blue)\r\n}\r\n\r\nresetHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nstopHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nif (initPlayerHandler) initPlayerHandler()\r\nif (displayHandler) displayHandler()\r\nCutebotPro.setTrackType(TrackType.WhiteOnBlack)\r\n\r\nbasic.forever(function () {\r\n    if (isPlaying && !isPlaying()) return\r\n    if (CutebotPro.readTrack() != Track.OffTrack) {\r\n        CutebotPro.ledColor(Led.Both, Color.Red)\r\n    }\r\n    else {\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n})\r\n\r\nlet outOfFieldHandler: prmhandler\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Sumo\"\r\n//% block.loc.nl=\"Sumo\"\r\nnamespace SumoPlayer {\r\n\r\n    let fielddiameter = 100 // cm\r\n\r\n    //% subcategory=\"Bewegen\"\r\n    //% block=\"stop\"\r\n    //% block.loc.nl=\"stop\"\r\n    export function stop() {\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"when %side is out of the field\"\r\n    //% block.loc.nl=\"wanneer %side buiten het speelveld is\"\r\n    export function onOutOfField(side: Side, code: (prm:number) => prmhandler) {\r\n        outOfFieldHandler = code(side)\r\n    }\r\n\r\n    //% block=\"move %dir and %bend\"\r\n    //% block.loc.nl=\"rijd %dir en %bend\"\r\n    export function move(dir: Move, bend: Bend) {\r\n        let speed: number\r\n        if (dir == Move.Forward) speed = 20\r\n        else speed = -20\r\n        switch (bend) {\r\n            case Bend.None: CutebotPro.speed(speed, speed); break;\r\n            case Bend.Left: CutebotPro.speed(speed / 2, speed); break;\r\n            case Bend.Right: CutebotPro.speed(speed, speed / 2); break;\r\n        }\r\n    }\r\n\r\n    //% block=\"push the opponent\"\r\n    //% block.loc.nl=\"duw de tegenstander\"\r\n    export function pushOpponent() {\r\n        let cm = CutebotPro.readDistance()\r\n        if (cm > 20) return\r\n        CutebotPro.speed(100, 100)\r\n    }\r\n\r\n    //% block=\"run to the opponent\"\r\n    //% block.loc.nl=\"rijd naar de tegenstander\"\r\n    export function runToOpponent() {\r\n        let cm: number\r\n        let tm = control.millis() + 5000\r\n        CutebotPro.speed(20, 20)\r\n        do {\r\n            cm = CutebotPro.readDistance()\r\n            if (cm > fielddiameter) {\r\n                CutebotPro.speed(0, 0)\r\n                return;\r\n            }\r\n        } while (cm > 20 && control.millis() < tm)\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"turn to the opponent\"\r\n    //% block.loc.nl=\"draai richting tegenstander\"\r\n    export function findOpponent() {\r\n        CutebotPro.speed(-15, 15)\r\n        while (CutebotPro.readDistance() > fielddiameter) { }\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn %led color %color\"\r\n    //% block.loc.nl=\"kleur %led %color\"\r\n    //% color.defl=Color.White\r\n    export function showColor(led: Led, color: Color) {\r\n        CutebotPro.ledColor(led, color)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn both leds off\"\r\n    //% block.loc.nl=\"schakel beide leds uit\"\r\n    export function turnLedsOff() {\r\n        CutebotPro.ledColor(Led.Both, Color.None)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"tornado\"\r\n    //% block.loc.nl=\"tornado\"\r\n    export function tornado() {\r\n        let on = true\r\n        for (let speed = 10; speed < 50; speed += 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Black)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        for (let speed = 50; speed >= 0; speed -= 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Black)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"shake\"\r\n    //% block.loc.nl=\"schudden\"\r\n    export function shake() {\r\n        for (let i = 0; i < 6; i++) {\r\n            if (showPlayerHandler) showPlayerHandler()\r\n            CutebotPro.speed(30, 30)\r\n            basic.pause(200)\r\n            CutebotPro.ledColor(Led.Both, Color.Black)\r\n            CutebotPro.speed(-30, -30)\r\n            basic.pause(230)\r\n        }\r\n        CutebotPro.speed(0, 0)\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n}\r\n\r\n\r\n\r\n////////////////////\r\n// TEST-PROGRAMMA //\r\n////////////////////\r\n\r\nMATCH = MatchStatus.Play\r\nbasic.forever(function() {\r\n})\r\n","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:ETmbit/general#50a144080fdbd8fb9bbefaa9a369108262fa31d4\",\n        \"match\": \"github:ETmbit/match#191656141aa933f8a0672849baaa5e4ad64b18fa\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1758447449419,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"////////////////////\r\n//################//\r\n//##            ##//\r\n//##  track.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum TrackType {\r\n    //% block=\"black on white\"\r\n    //% block.loc.nl=\"zwart op wit\"\r\n    BlackOnWhite,\r\n    //% block=\"white on black\"\r\n    //% block.loc.nl=\"wit op zwart\"\r\n    WhiteOnBlack,\r\n}\r\n\r\nenum TrackMask {\r\n    //% block=\"two sensors\"\r\n    //% block.loc.nl=\"twee sensoren\"\r\n    Track2 = 10,\r\n    //% block=\"three sensors\"\r\n    //% block.loc.nl=\"drie sensoren\"\r\n    Track3 = 14,\r\n    //% block=\"four sensors\"\r\n    //% block.loc.nl=\"vier sensoren\"\r\n    Track4 = 27,\r\n    //% block=\"five sensors\"\r\n    //% block.loc.nl=\"vijf sensoren\"\r\n    Track5 = 31,\r\n}\r\n\r\nenum Track {\r\n    //% block=\"off the track\"\r\n    //% block.loc.nl=\"van de lijn af\"\r\n    OffTrack = 0,\r\n    //% block=\"the track at far left\"\r\n    //% block.loc.nl=\"de lijn op uiterst links\"\r\n    FarLeft = 1,\r\n    //% block=\"the track at left\"\r\n    //% block.loc.nl=\"de lijn op links\"\r\n    Left = 2,\r\n    //% block=\"on the track\"\r\n    //% block.loc.nl=\"op de lijn\"\r\n    Mid = 4,\r\n    //% block=\"the track at right\"\r\n    //% block.loc.nl=\"de lijn op rechts\"\r\n    Right = 8,\r\n    //% block=\"the track at far right\"\r\n    //% block.loc.nl=\"de lijn op uiterst rechts\"\r\n    FarRight = 16,\r\n}\r\n\r\nfunction trackPosition(track: number, mask = TrackMask.Track2, tracktype = TrackType.BlackOnWhite): Track {\r\n    if (tracktype == TrackType.WhiteOnBlack) track = ~track\r\n    track = (track & mask)\r\n\r\n    if (!track)\r\n        return Track.OffTrack\r\n    if (track & 17) { // extreme left or right sensor\r\n        if (track & 4) { // mid sensor too\r\n            if (track & 1) return Track.Left\r\n            if (track & 16) return Track.Right\r\n        }\r\n        else { // whitout mid sensor\r\n            if (track & 1) return Track.FarLeft\r\n            if (track & 16) return Track.FarRight\r\n        }\r\n    }\r\n    if (((track & 10) == 10) ||   // both left and right sensor\r\n        ((track & 4) == track)) // mid sensor only\r\n        return Track.Mid\r\n    if (track & 2)\r\n        return Track.Left\r\n    if (track & 8)\r\n        return Track.Right\r\n    return Track.OffTrack\r\n}\r\n\r\n\r\n////////////////////\r\n//################//\r\n//##            ##//\r\n//##  servo.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum ServoType {\r\n    Continuous = 0,\r\n    ST90 = 90,\r\n    ST180 = 180,\r\n    ST270 = 270,\r\n    ST360 = 360,\r\n}\r\n\r\nnamespace Servo {\r\n\r\n    export class Device {\r\n\r\n        pin: AnalogPin\r\n        servo: ServoType\r\n        minpw: number = 1000\r\n        maxpw: number = 2000\r\n\r\n        constructor(_pin: AnalogPin, _type: ServoType) {\r\n            this.pin = _pin\r\n            this.servo = _type\r\n        }\r\n\r\n        setPulse(_min: number, _max: number) {\r\n            this.minpw = _min;\r\n            this.maxpw = _max;\r\n        }\r\n\r\n        angle(_angle: number) {\r\n            _angle = Math.map(_angle, this.minpw, this.maxpw, 0, this.servo)\r\n            pins.servoSetPulse(this.pin, _angle)\r\n            //pins.servoWritePin(this.pin, _angle)\r\n        }\r\n\r\n        speed(_speed: number) {\r\n            _speed = Math.map(_speed, this.minpw, this.maxpw, -100, 100)\r\n            pins.servoSetPulse(this.pin, _speed)\r\n        }\r\n    }\r\n\r\n    export function create(_pin: AnalogPin, _type: ServoType): Device {\r\n        let device = new Device(_pin, _type)\r\n        return device\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////\r\n//#####################//\r\n//##                 ##//\r\n//##  cutebotpro.ts  ##//\r\n//##                 ##//\r\n//#####################//\r\n/////////////////////////\r\n\r\nenum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n}\r\n\r\nenum ServoPort {\r\n    S1,\r\n    S2,\r\n    S3,\r\n    S4,\r\n}\r\n\r\nenum GpioPort {\r\n    G1,\r\n    G2,\r\n    G3,\r\n    G4,\r\n}\r\n\r\nnamespace CutebotPro {\r\n    // supports CutebotPro V2\r\n\r\n    const cutebotProAddr = 0x10\r\n\r\n    let trackType = TrackType.BlackOnWhite\r\n\r\n    let AnalogGP = [AnalogPin.P1, AnalogPin.P2, AnalogPin.P13, AnalogPin.P14]\r\n    let DigitalGP = [DigitalPin.P1, DigitalPin.P2, DigitalPin.P13, DigitalPin.P14]\r\n\r\n    function delay_ms(ms: number) {\r\n        let endTime = input.runningTime() + ms;\r\n        while (endTime > input.runningTime()) { }\r\n    }\r\n\r\n    export function pid_delay_ms(ms: number) {\r\n        let time = control.millis() + ms\r\n        while (1) {\r\n            i2cCommandSend(0xA0, [0x05])\r\n            if (pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false) || control.millis() >= time) {\r\n                basic.pause(500)\r\n                break\r\n            }\r\n            basic.pause(10)\r\n        }\r\n    }\r\n\r\n    export function i2cCommandSend(command: number, params: number[]) {\r\n        let buff = pins.createBuffer(params.length + 4);\r\n        buff[0] = 0xFF;\r\n        buff[1] = 0xF9;\r\n        buff[2] = command;\r\n        buff[3] = params.length;\r\n        for (let i = 0; i < params.length; i++) {\r\n            buff[i + 4] = params[i];\r\n        }\r\n        pins.i2cWriteBuffer(cutebotProAddr, buff);\r\n        delay_ms(1);\r\n    }\r\n\r\n    // MOTION MODULE\r\n\r\n    export function speed(left: number, right: number): void {\r\n        // speed in % [-100, 100]\r\n\r\n        let direction: number = 0;\r\n        if (left < 0) direction |= 0x01;\r\n        if (right < 0) direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(left), Math.abs(right), direction]);\r\n    }\r\n\r\n    export function move(speed: number, distance: number): void {\r\n        // speed in % [-100, -40] backward and [40, 100] forward\r\n        // distance in cm [0, 6000]\r\n\r\n        distance = ((distance > 6000 ? 6000 : distance) < 0 ? 0 : distance);\r\n        distance *= 10 // cm to mm\r\n        let distance_h = distance >> 8;\r\n        let distance_l = distance & 0xFF;\r\n\r\n        let direction2: number\r\n        if (speed <= 0) {\r\n            speed = -speed\r\n            direction2 = 3\r\n        } else\r\n            direction2 = 0\r\n\r\n        speed *= 5 // % to mm/s\r\n        speed = ((speed > 500 ? 500 : speed) < 200 ? 200 : speed);\r\n        let speed_h = speed >> 8;\r\n        let speed_l = speed & 0xFF;\r\n\r\n        i2cCommandSend(0x84, [distance_h, distance_l, speed_h, speed_l, direction2]);\r\n        pid_delay_ms(Math.round(distance * 1.0 / 1000 * 8000 + 3000))\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function motor(speed: number): void {\r\n        let direction: number = (speed > 0 ? 1 : 0)\r\n        i2cCommandSend(0x30, [Math.abs(speed), direction])\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    export function servoAngle(port: ServoPort, angle: number, _type: ServoType = ServoType.ST180) {\r\n        angle = Math.map(angle, 0, _type, 0, 180)\r\n        i2cCommandSend(0x40, [port, angle])\r\n    }\r\n\r\n    export function servoSpeed(port: ServoPort, speed: number) {\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        i2cCommandSend(0x40, [port, speed])\r\n    }\r\n\r\n    // LED MODULE\r\n\r\n    export function ledColor(led: Led, color: Color): void {\r\n        let rgbval = fromColor(color)\r\n        let red = (rgbval >> 16) & 0xFF;\r\n        let green = (rgbval >> 8) & 0xFF;\r\n        let blue = (rgbval) & 0xFF;\r\n        i2cCommandSend(0x20, [led, red, green, blue]);\r\n    }\r\n\r\n    // TRACKING MODULE\r\n\r\n    export function setTrackType(_type: TrackType) {\r\n        trackType = _type\r\n    }\r\n\r\n    export function readTrack(): Track {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = (state & 3) + ((state & 12) << 1)\r\n        track = trackPosition(track, TrackMask.Track4, trackType)\r\n        return track\r\n    }\r\n\r\n    export function isTrackAtLeft(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Left || track == Track.FarLeft)\r\n    }\r\n\r\n    export function isTrackAtRight(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Right || track == Track.FarRight)\r\n    }\r\n\r\n    export function isOnTrack(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Mid)\r\n    }\r\n\r\n    export function isOffTrack(): boolean {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.OffTrack)\r\n    }\r\n\r\n    // DISTANCE MODULE\r\n\r\n    export function readDistance(): number {\r\n        // send pulse\r\n\r\n        pins.setPull(DigitalPin.P8, PinPullMode.PullNone);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(DigitalPin.P8, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n\r\n        // read pulse\r\n\r\n        // the next code is replacing the original since\r\n        // driving the motors causes interference with pulseIn\r\n\r\n        while (!pins.digitalReadPin(DigitalPin.P12)) { }\r\n        let tm1 = input.runningTimeMicros()\r\n        while (pins.digitalReadPin(DigitalPin.P12)) {\r\n            if (input.runningTimeMicros() - tm1 > 7288)\r\n                return 999 // timeout at further than 250 cm\r\n        }\r\n        let tm2 = input.runningTimeMicros()\r\n        let dist = (tm2 - tm1) * 343 / 20000\r\n        return Math.floor(dist)\r\n    }\r\n\r\n    // GPIO MODULE\r\n\r\n    export function analogPin(port: GpioPort): AnalogPin {\r\n        return AnalogGP[port]\r\n    }\r\n\r\n    export function digitalPin(port: GpioPort): DigitalPin {\r\n        return DigitalGP[port]\r\n    }\r\n\r\n}\r\n\r\n\r\n//////////////////////////\r\n//######################//\r\n//##                  ##//\r\n//##  sumo-player.ts  ##//\r\n//##                  ##//\r\n//######################//\r\n//////////////////////////\r\n\r\nlet ROLE = Player.Green\r\n\r\nenum Bend {\r\n    //% block=\"go straight\"\r\n    //% block.loc.nl=\"ga rechtdoor\"\r\n    None,\r\n    //% block=\"turn to the left\"\r\n    //% block.loc.nl=\"draai naar links\"\r\n    Left,\r\n    //% block=\"turn to the right\"\r\n    //% block.loc.nl=\"draai naar rechts\"\r\n    Right\r\n}\r\n\r\nenum Side {\r\n    //% block=\"one of the sides\"\r\n    //% block.loc.nl=\"n van beide kanten\"\r\n    Both,\r\n    //% block=\"the left side\"\r\n    //% block.loc.nl=\"de linker kant\"\r\n    Left,\r\n    //% block=\"the right side\"\r\n    //% block.loc.nl=\"de rechter kant\"\r\n    Right\r\n}\r\n\r\n// setPlayerHandler is called from match.ts\r\nsetPlayerHandler = (player: Player) => {\r\n    ROLE = player\r\n}\r\n\r\n// showPlayerHandler is called from match.ts and this extension\r\nshowPlayerHandler = () => {\r\n    if (ROLE == Player.Green)\r\n        CutebotPro.ledColor(Led.Both, Color.Green)\r\n    else\r\n        CutebotPro.ledColor(Led.Both, Color.Blue)\r\n}\r\n\r\nresetHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nstopHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nif (initPlayerHandler) initPlayerHandler()\r\nif (displayHandler) displayHandler()\r\nCutebotPro.setTrackType(TrackType.WhiteOnBlack)\r\n\r\nlet outOfFieldHandler: handler\r\n\r\nbasic.forever(function () {\r\n    if (isPlaying && !isPlaying()) return\r\n    if (CutebotPro.readTrack() != Track.OffTrack) {\r\n        CutebotPro.ledColor(Led.Both, Color.Red)\r\n        if (outOfFieldHandler) outOfFieldHandler()\r\n    }\r\n    else {\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n})\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Sumo\"\r\n//% block.loc.nl=\"Sumo\"\r\nnamespace SumoPlayer {\r\n\r\n    let fielddiameter = 100 // cm\r\n\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"when the robot is out of the field\"\r\n    //% block.loc.nl=\"wanneer de robot buiten het speelveld is\"\r\n    export function onOutOfField(code: () => handler) {\r\n        outOfFieldHandler = code()\r\n    }\r\n\r\n    //% block=\"at %side out of the field\"\r\n    //% block=\"aan %side uit het veld\"\r\n    export function isOutOfField(side: Side): boolean {\r\n        switch (side) {\r\n            case Side.Both:     return CutebotPro.isOnTrack()\r\n            case Side.Left:     return CutebotPro.isTrackAtLeft()\r\n            case Side.Right:    return CutebotPro.isTrackAtRight()\r\n        }\r\n        return false\r\n    }\r\n\r\n    //% block=\"stop\"\r\n    //% block.loc.nl=\"stop\"\r\n    export function stop() {\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"move %dir and %bend\"\r\n    //% block.loc.nl=\"rijd %dir en %bend\"\r\n    export function move(dir: Move, bend: Bend) {\r\n        let speed: number\r\n        if (dir == Move.Forward) speed = 20\r\n        else speed = -20\r\n        switch (bend) {\r\n            case Bend.None: CutebotPro.speed(speed, speed); break;\r\n            case Bend.Left: CutebotPro.speed(speed / 2, speed); break;\r\n            case Bend.Right: CutebotPro.speed(speed, speed / 2); break;\r\n        }\r\n    }\r\n\r\n    //% block=\"push the opponent\"\r\n    //% block.loc.nl=\"duw de tegenstander\"\r\n    export function pushOpponent() {\r\n        let cm = CutebotPro.readDistance()\r\n        if (cm > 20) return\r\n        CutebotPro.speed(100, 100)\r\n    }\r\n\r\n    //% block=\"run to the opponent\"\r\n    //% block.loc.nl=\"rijd naar de tegenstander\"\r\n    export function runToOpponent() {\r\n        let cm: number\r\n        let tm = control.millis() + 5000\r\n        CutebotPro.speed(20, 20)\r\n        do {\r\n            if (isPlaying && !isPlaying()) return\r\n            cm = CutebotPro.readDistance()\r\n            if (cm > fielddiameter) {\r\n                CutebotPro.speed(0, 0)\r\n                return;\r\n            }\r\n        } while (cm > 20 && control.millis() < tm)\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"turn to the opponent\"\r\n    //% block.loc.nl=\"draai richting tegenstander\"\r\n    export function findOpponent() {\r\n        CutebotPro.speed(-15, 15)\r\n        while (CutebotPro.readDistance() > fielddiameter) { }\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn %led color %color\"\r\n    //% block.loc.nl=\"kleur %led %color\"\r\n    //% color.defl=Color.White\r\n    export function showColor(led: Led, color: Color) {\r\n        CutebotPro.ledColor(led, color)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn both leds off\"\r\n    //% block.loc.nl=\"schakel beide leds uit\"\r\n    export function turnLedsOff() {\r\n        CutebotPro.ledColor(Led.Both, Color.None)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"tornado\"\r\n    //% block.loc.nl=\"tornado\"\r\n    export function tornado() {\r\n        let on = true\r\n        for (let speed = 10; speed < 50; speed += 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Black)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        for (let speed = 50; speed >= 0; speed -= 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Black)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"shake\"\r\n    //% block.loc.nl=\"schudden\"\r\n    export function shake() {\r\n        for (let i = 0; i < 6; i++) {\r\n            if (showPlayerHandler) showPlayerHandler()\r\n            CutebotPro.speed(30, 30)\r\n            basic.pause(200)\r\n            CutebotPro.ledColor(Led.Both, Color.Black)\r\n            CutebotPro.speed(-30, -30)\r\n            basic.pause(230)\r\n        }\r\n        CutebotPro.speed(0, 0)\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n}\r\n\r\n\r\n\r\n////////////////////\r\n// TEST-PROGRAMMA //\r\n////////////////////\r\n\r\nMATCH = MatchStatus.Play\r\n\r\noutOfFieldHandler = () => {\r\n    if (SumoPlayer.isOutOfField(Side.Both))\r\n        basic.showIcon(IconNames.Sad)\r\n    else\r\n    if (SumoPlayer.isOutOfField(Side.Left))\r\n        basic.showArrow(ArrowNames.West)\r\n    else\r\n    if (SumoPlayer.isOutOfField(Side.Right))\r\n        basic.showArrow(ArrowNames.East)\r\n    else\r\n        basic.showIcon(IconNames.Happy)\r\n}\r\n","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:ETmbit/general#50a144080fdbd8fb9bbefaa9a369108262fa31d4\",\n        \"match\": \"github:ETmbit/match#191656141aa933f8a0672849baaa5e4ad64b18fa\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1758449282706,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"////////////////////\r\n//################//\r\n//##            ##//\r\n//##  track.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum TrackType {\r\n    //% block=\"black on white\"\r\n    //% block.loc.nl=\"zwart op wit\"\r\n    BlackOnWhite,\r\n    //% block=\"white on black\"\r\n    //% block.loc.nl=\"wit op zwart\"\r\n    WhiteOnBlack,\r\n}\r\n\r\nenum TrackMask {\r\n    //% block=\"two sensors\"\r\n    //% block.loc.nl=\"twee sensoren\"\r\n    Track2 = 10,\r\n    //% block=\"three sensors\"\r\n    //% block.loc.nl=\"drie sensoren\"\r\n    Track3 = 14,\r\n    //% block=\"four sensors\"\r\n    //% block.loc.nl=\"vier sensoren\"\r\n    Track4 = 27,\r\n    //% block=\"five sensors\"\r\n    //% block.loc.nl=\"vijf sensoren\"\r\n    Track5 = 31,\r\n}\r\n\r\nenum Track {\r\n    //% block=\"off the track\"\r\n    //% block.loc.nl=\"van de lijn af\"\r\n    OffTrack = 0,\r\n    //% block=\"the track at far left\"\r\n    //% block.loc.nl=\"de lijn op uiterst links\"\r\n    FarLeft = 1,\r\n    //% block=\"the track at left\"\r\n    //% block.loc.nl=\"de lijn op links\"\r\n    Left = 2,\r\n    //% block=\"on the track\"\r\n    //% block.loc.nl=\"op de lijn\"\r\n    Mid = 4,\r\n    //% block=\"the track at right\"\r\n    //% block.loc.nl=\"de lijn op rechts\"\r\n    Right = 8,\r\n    //% block=\"the track at far right\"\r\n    //% block.loc.nl=\"de lijn op uiterst rechts\"\r\n    FarRight = 16,\r\n}\r\n\r\nfunction trackPosition(track: number, mask = TrackMask.Track2, tracktype = TrackType.BlackOnWhite): Track {\r\n    if (tracktype == TrackType.WhiteOnBlack) track = ~track\r\n    track = (track & mask)\r\n\r\n    if (!track)\r\n        return Track.OffTrack\r\n    if (track & 17) { // extreme left or right sensor\r\n        if (track & 4) { // mid sensor too\r\n            if (track & 1) return Track.Left\r\n            if (track & 16) return Track.Right\r\n        }\r\n        else { // whitout mid sensor\r\n            if (track & 1) return Track.FarLeft\r\n            if (track & 16) return Track.FarRight\r\n        }\r\n    }\r\n    if (((track & 10) == 10) ||   // both left and right sensor\r\n        ((track & 4) == track)) // mid sensor only\r\n        return Track.Mid\r\n    if (track & 2)\r\n        return Track.Left\r\n    if (track & 8)\r\n        return Track.Right\r\n    return Track.OffTrack\r\n}\r\n\r\n\r\n////////////////////\r\n//################//\r\n//##            ##//\r\n//##  servo.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum ServoType {\r\n    Continuous = 0,\r\n    ST90 = 90,\r\n    ST180 = 180,\r\n    ST270 = 270,\r\n    ST360 = 360,\r\n}\r\n\r\nnamespace Servo {\r\n\r\n    export class Device {\r\n\r\n        pin: AnalogPin\r\n        servo: ServoType\r\n        minpw: number = 1000\r\n        maxpw: number = 2000\r\n\r\n        constructor(_pin: AnalogPin, _type: ServoType) {\r\n            this.pin = _pin\r\n            this.servo = _type\r\n        }\r\n\r\n        setPulse(_min: number, _max: number) {\r\n            this.minpw = _min;\r\n            this.maxpw = _max;\r\n        }\r\n\r\n        angle(_angle: number) {\r\n            _angle = Math.map(_angle, this.minpw, this.maxpw, 0, this.servo)\r\n            pins.servoSetPulse(this.pin, _angle)\r\n            //pins.servoWritePin(this.pin, _angle)\r\n        }\r\n\r\n        speed(_speed: number) {\r\n            _speed = Math.map(_speed, this.minpw, this.maxpw, -100, 100)\r\n            pins.servoSetPulse(this.pin, _speed)\r\n        }\r\n    }\r\n\r\n    export function create(_pin: AnalogPin, _type: ServoType): Device {\r\n        let device = new Device(_pin, _type)\r\n        return device\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////\r\n//#####################//\r\n//##                 ##//\r\n//##  cutebotpro.ts  ##//\r\n//##                 ##//\r\n//#####################//\r\n/////////////////////////\r\n\r\nenum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n}\r\n\r\nenum ServoPort {\r\n    S1,\r\n    S2,\r\n    S3,\r\n    S4,\r\n}\r\n\r\nenum GpioPort {\r\n    G1,\r\n    G2,\r\n    G3,\r\n    G4,\r\n}\r\n\r\nnamespace CutebotPro {\r\n    // supports CutebotPro V2\r\n\r\n    const cutebotProAddr = 0x10\r\n\r\n    let trackType = TrackType.BlackOnWhite\r\n\r\n    let AnalogGP = [AnalogPin.P1, AnalogPin.P2, AnalogPin.P13, AnalogPin.P14]\r\n    let DigitalGP = [DigitalPin.P1, DigitalPin.P2, DigitalPin.P13, DigitalPin.P14]\r\n\r\n    function delay_ms(ms: number) {\r\n        let endTime = input.runningTime() + ms;\r\n        while (endTime > input.runningTime()) { }\r\n    }\r\n\r\n    export function pid_delay_ms(ms: number) {\r\n        let time = control.millis() + ms\r\n        while (1) {\r\n            i2cCommandSend(0xA0, [0x05])\r\n            if (pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false) || control.millis() >= time) {\r\n                basic.pause(500)\r\n                break\r\n            }\r\n            basic.pause(10)\r\n        }\r\n    }\r\n\r\n    export function i2cCommandSend(command: number, params: number[]) {\r\n        let buff = pins.createBuffer(params.length + 4);\r\n        buff[0] = 0xFF;\r\n        buff[1] = 0xF9;\r\n        buff[2] = command;\r\n        buff[3] = params.length;\r\n        for (let i = 0; i < params.length; i++) {\r\n            buff[i + 4] = params[i];\r\n        }\r\n        pins.i2cWriteBuffer(cutebotProAddr, buff);\r\n        delay_ms(1);\r\n    }\r\n\r\n    // MOTION MODULE\r\n\r\n    export function speed(left: number, right: number): void {\r\n        // speed in % [-100, 100]\r\n\r\n        let direction: number = 0;\r\n        if (left < 0) direction |= 0x01;\r\n        if (right < 0) direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(left), Math.abs(right), direction]);\r\n    }\r\n\r\n    export function move(speed: number, distance: number): void {\r\n        // speed in % [-100, -40] backward and [40, 100] forward\r\n        // distance in cm [0, 6000]\r\n\r\n        distance = ((distance > 6000 ? 6000 : distance) < 0 ? 0 : distance);\r\n        distance *= 10 // cm to mm\r\n        let distance_h = distance >> 8;\r\n        let distance_l = distance & 0xFF;\r\n\r\n        let direction2: number\r\n        if (speed <= 0) {\r\n            speed = -speed\r\n            direction2 = 3\r\n        } else\r\n            direction2 = 0\r\n\r\n        speed *= 5 // % to mm/s\r\n        speed = ((speed > 500 ? 500 : speed) < 200 ? 200 : speed);\r\n        let speed_h = speed >> 8;\r\n        let speed_l = speed & 0xFF;\r\n\r\n        i2cCommandSend(0x84, [distance_h, distance_l, speed_h, speed_l, direction2]);\r\n        pid_delay_ms(Math.round(distance * 1.0 / 1000 * 8000 + 3000))\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function motor(speed: number): void {\r\n        let direction: number = (speed > 0 ? 1 : 0)\r\n        i2cCommandSend(0x30, [Math.abs(speed), direction])\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    export function servoAngle(port: ServoPort, angle: number, _type: ServoType = ServoType.ST180) {\r\n        angle = Math.map(angle, 0, _type, 0, 180)\r\n        i2cCommandSend(0x40, [port, angle])\r\n    }\r\n\r\n    export function servoSpeed(port: ServoPort, speed: number) {\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        i2cCommandSend(0x40, [port, speed])\r\n    }\r\n\r\n    // LED MODULE\r\n\r\n    export function ledColor(led: Led, color: Color): void {\r\n        let rgbval = fromColor(color)\r\n        let red = (rgbval >> 16) & 0xFF;\r\n        let green = (rgbval >> 8) & 0xFF;\r\n        let blue = (rgbval) & 0xFF;\r\n        i2cCommandSend(0x20, [led, red, green, blue]);\r\n    }\r\n\r\n    // TRACKING MODULE\r\n\r\n    export function setTrackType(_type: TrackType) {\r\n        trackType = _type\r\n    }\r\n\r\n    export function readTrack(): Track {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = (state & 3) + ((state & 12) << 1)\r\n        track = trackPosition(track, TrackMask.Track4, trackType)\r\n        return track\r\n    }\r\n\r\n    export function isTrackAtLeft(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Left || track == Track.FarLeft)\r\n    }\r\n\r\n    export function isTrackAtRight(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Right || track == Track.FarRight)\r\n    }\r\n\r\n    export function isOnTrack(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Mid)\r\n    }\r\n\r\n    export function isOffTrack(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.OffTrack)\r\n    }\r\n\r\n    // DISTANCE MODULE\r\n\r\n    export function readDistance(): number {\r\n        // send pulse\r\n\r\n        pins.setPull(DigitalPin.P8, PinPullMode.PullNone);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(DigitalPin.P8, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n\r\n        // read pulse\r\n\r\n        // the next code is replacing the original since\r\n        // driving the motors causes interference with pulseIn\r\n\r\n        while (!pins.digitalReadPin(DigitalPin.P12)) { }\r\n        let tm1 = input.runningTimeMicros()\r\n        while (pins.digitalReadPin(DigitalPin.P12)) {\r\n            if (input.runningTimeMicros() - tm1 > 7288)\r\n                return 999 // timeout at further than 250 cm\r\n        }\r\n        let tm2 = input.runningTimeMicros()\r\n        let dist = (tm2 - tm1) * 343 / 20000\r\n        return Math.floor(dist)\r\n    }\r\n\r\n    // GPIO MODULE\r\n\r\n    export function analogPin(port: GpioPort): AnalogPin {\r\n        return AnalogGP[port]\r\n    }\r\n\r\n    export function digitalPin(port: GpioPort): DigitalPin {\r\n        return DigitalGP[port]\r\n    }\r\n}\r\n\r\n\r\n//////////////////////////\r\n//######################//\r\n//##                  ##//\r\n//##  sumo-player.ts  ##//\r\n//##                  ##//\r\n//######################//\r\n//////////////////////////\r\n\r\nlet ROLE = Player.Green\r\n\r\nenum Bend {\r\n    //% block=\"go straight\"\r\n    //% block.loc.nl=\"ga rechtdoor\"\r\n    None,\r\n    //% block=\"turn to the left\"\r\n    //% block.loc.nl=\"draai naar links\"\r\n    Left,\r\n    //% block=\"turn to the right\"\r\n    //% block.loc.nl=\"draai naar rechts\"\r\n    Right\r\n}\r\n\r\nenum Side {\r\n    //% block=\"one of the sides\"\r\n    //% block.loc.nl=\"n van beide kanten\"\r\n    Both,\r\n    //% block=\"the left side\"\r\n    //% block.loc.nl=\"de linker kant\"\r\n    Left,\r\n    //% block=\"the right side\"\r\n    //% block.loc.nl=\"de rechter kant\"\r\n    Right\r\n}\r\n\r\n// setPlayerHandler is called from match.ts\r\nsetPlayerHandler = (player: Player) => {\r\n    ROLE = player\r\n}\r\n\r\n// showPlayerHandler is called from match.ts and this extension\r\nshowPlayerHandler = () => {\r\n    if (ROLE == Player.Green)\r\n        CutebotPro.ledColor(Led.Both, Color.Green)\r\n    else\r\n        CutebotPro.ledColor(Led.Both, Color.Blue)\r\n}\r\n\r\nresetHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nstopHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nif (initPlayerHandler) initPlayerHandler()\r\nif (displayHandler) displayHandler()\r\nCutebotPro.setTrackType(TrackType.WhiteOnBlack)\r\n\r\nlet outOfFieldHandler: handler\r\n\r\nbasic.forever(function () {\r\n    if (isPlaying && !isPlaying()) return\r\n    if (CutebotPro.readTrack() != Track.OffTrack) {\r\n        CutebotPro.ledColor(Led.Both, Color.Red)\r\n        if (outOfFieldHandler) outOfFieldHandler()\r\n    }\r\n    else {\r\n        if (showPlayerHandler) showPlayerHandler()\r\nbasic.showIcon(IconNames.Happy)\r\n    }\r\n})\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Sumo\"\r\n//% block.loc.nl=\"Sumo\"\r\nnamespace SumoPlayer {\r\n\r\n    let fielddiameter = 100 // cm\r\n\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"when the robot is out of the field\"\r\n    //% block.loc.nl=\"wanneer de robot buiten het speelveld is\"\r\n    export function onOutOfField(code: () => handler) {\r\n        outOfFieldHandler = code()\r\n    }\r\n\r\n    //% block=\"at %side out of the field\"\r\n    //% block=\"aan %side uit het veld\"\r\n    export function isOutOfField(side: Side): boolean {\r\n        switch (side) {\r\n            case Side.Both:     return !CutebotPro.isOffTrack()\r\n            case Side.Left:     return CutebotPro.isTrackAtLeft()\r\n            case Side.Right:    return CutebotPro.isTrackAtRight()\r\n        }\r\n        return false\r\n    }\r\n\r\n    //% block=\"stop\"\r\n    //% block.loc.nl=\"stop\"\r\n    export function stop() {\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"move %dir and %bend\"\r\n    //% block.loc.nl=\"rijd %dir en %bend\"\r\n    export function move(dir: Move, bend: Bend) {\r\n        let speed: number\r\n        if (dir == Move.Forward) speed = 20\r\n        else speed = -20\r\n        switch (bend) {\r\n            case Bend.None: CutebotPro.speed(speed, speed); break;\r\n            case Bend.Left: CutebotPro.speed(speed / 2, speed); break;\r\n            case Bend.Right: CutebotPro.speed(speed, speed / 2); break;\r\n        }\r\n    }\r\n\r\n    //% block=\"push the opponent\"\r\n    //% block.loc.nl=\"duw de tegenstander\"\r\n    export function pushOpponent() {\r\n        let cm = CutebotPro.readDistance()\r\n        if (cm > 20) return\r\n        CutebotPro.speed(100, 100)\r\n    }\r\n\r\n    //% block=\"run to the opponent\"\r\n    //% block.loc.nl=\"rijd naar de tegenstander\"\r\n    export function runToOpponent() {\r\n        let cm: number\r\n        let tm = control.millis() + 5000\r\n        CutebotPro.speed(20, 20)\r\n        do {\r\n            if (isPlaying && !isPlaying()) return\r\n            cm = CutebotPro.readDistance()\r\n            if (cm > fielddiameter) {\r\n                CutebotPro.speed(0, 0)\r\n                return;\r\n            }\r\n        } while (cm > 20 && control.millis() < tm)\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"turn to the opponent\"\r\n    //% block.loc.nl=\"draai richting tegenstander\"\r\n    export function findOpponent() {\r\n        CutebotPro.speed(-15, 15)\r\n        while (CutebotPro.readDistance() > fielddiameter) {\r\n            if (isPlaying && !isPlaying()) return\r\n            basic.pause(1)\r\n        }\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn %led color %color\"\r\n    //% block.loc.nl=\"kleur %led %color\"\r\n    //% color.defl=Color.White\r\n    export function showColor(led: Led, color: Color) {\r\n        CutebotPro.ledColor(led, color)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn both leds off\"\r\n    //% block.loc.nl=\"schakel beide leds uit\"\r\n    export function turnLedsOff() {\r\n        CutebotPro.ledColor(Led.Both, Color.None)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"tornado\"\r\n    //% block.loc.nl=\"tornado\"\r\n    export function tornado() {\r\n        let on = true\r\n        for (let speed = 10; speed < 50; speed += 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Black)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        for (let speed = 50; speed >= 0; speed -= 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Black)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"shake\"\r\n    //% block.loc.nl=\"schudden\"\r\n    export function shake() {\r\n        for (let i = 0; i < 6; i++) {\r\n            if (showPlayerHandler) showPlayerHandler()\r\n            CutebotPro.speed(30, 30)\r\n            basic.pause(200)\r\n            CutebotPro.ledColor(Led.Both, Color.Black)\r\n            CutebotPro.speed(-30, -30)\r\n            basic.pause(230)\r\n        }\r\n        CutebotPro.speed(0, 0)\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n}\r\n\r\n\r\n\r\n////////////////////\r\n// TEST-PROGRAMMA //\r\n////////////////////\r\n\r\nMATCH = MatchStatus.Play\r\n\r\nbasic.forever(function() {\r\n    SumoPlayer.findOpponent()\r\n    SumoPlayer.runToOpponent()\r\n    SumoPlayer.pushOpponent()\r\n    General.wait(1)\r\n    SumoPlayer.stop()\r\n    General.wait(5)\r\n})\r\n","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:ETmbit/general#50a144080fdbd8fb9bbefaa9a369108262fa31d4\",\n        \"match\": \"github:ETmbit/match#191656141aa933f8a0672849baaa5e4ad64b18fa\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1758451084349,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"////////////////////\r\n//################//\r\n//##            ##//\r\n//##  track.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum TrackType {\r\n    //% block=\"black on white\"\r\n    //% block.loc.nl=\"zwart op wit\"\r\n    BlackOnWhite,\r\n    //% block=\"white on black\"\r\n    //% block.loc.nl=\"wit op zwart\"\r\n    WhiteOnBlack,\r\n}\r\n\r\nenum TrackMask {\r\n    //% block=\"two sensors\"\r\n    //% block.loc.nl=\"twee sensoren\"\r\n    Track2 = 10,\r\n    //% block=\"three sensors\"\r\n    //% block.loc.nl=\"drie sensoren\"\r\n    Track3 = 14,\r\n    //% block=\"four sensors\"\r\n    //% block.loc.nl=\"vier sensoren\"\r\n    Track4 = 27,\r\n    //% block=\"five sensors\"\r\n    //% block.loc.nl=\"vijf sensoren\"\r\n    Track5 = 31,\r\n}\r\n\r\nenum Track {\r\n    //% block=\"off the track\"\r\n    //% block.loc.nl=\"van de lijn af\"\r\n    OffTrack = 0,\r\n    //% block=\"the track at far left\"\r\n    //% block.loc.nl=\"de lijn op uiterst links\"\r\n    FarLeft = 1,\r\n    //% block=\"the track at left\"\r\n    //% block.loc.nl=\"de lijn op links\"\r\n    Left = 2,\r\n    //% block=\"on the track\"\r\n    //% block.loc.nl=\"op de lijn\"\r\n    Mid = 4,\r\n    //% block=\"the track at right\"\r\n    //% block.loc.nl=\"de lijn op rechts\"\r\n    Right = 8,\r\n    //% block=\"the track at far right\"\r\n    //% block.loc.nl=\"de lijn op uiterst rechts\"\r\n    FarRight = 16,\r\n}\r\n\r\nfunction trackPosition(track: number, mask = TrackMask.Track2, tracktype = TrackType.BlackOnWhite): Track {\r\n    if (tracktype == TrackType.WhiteOnBlack) track = ~track\r\n    track = (track & mask)\r\n\r\n    if (!track)\r\n        return Track.OffTrack\r\n    if (track & 17) { // extreme left or right sensor\r\n        if (track & 4) { // mid sensor too\r\n            if (track & 1) return Track.Left\r\n            if (track & 16) return Track.Right\r\n        }\r\n        else { // whitout mid sensor\r\n            if (track & 1) return Track.FarLeft\r\n            if (track & 16) return Track.FarRight\r\n        }\r\n    }\r\n    if (((track & 10) == 10) ||   // both left and right sensor\r\n        ((track & 4) == track)) // mid sensor only\r\n        return Track.Mid\r\n    if (track & 2)\r\n        return Track.Left\r\n    if (track & 8)\r\n        return Track.Right\r\n    return Track.OffTrack\r\n}\r\n\r\n\r\n////////////////////\r\n//################//\r\n//##            ##//\r\n//##  servo.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum ServoType {\r\n    Continuous = 0,\r\n    ST90 = 90,\r\n    ST180 = 180,\r\n    ST270 = 270,\r\n    ST360 = 360,\r\n}\r\n\r\nnamespace Servo {\r\n\r\n    export class Device {\r\n\r\n        pin: AnalogPin\r\n        servo: ServoType\r\n        minpw: number = 1000\r\n        maxpw: number = 2000\r\n\r\n        constructor(_pin: AnalogPin, _type: ServoType) {\r\n            this.pin = _pin\r\n            this.servo = _type\r\n        }\r\n\r\n        setPulse(_min: number, _max: number) {\r\n            this.minpw = _min;\r\n            this.maxpw = _max;\r\n        }\r\n\r\n        angle(_angle: number) {\r\n            _angle = Math.map(_angle, this.minpw, this.maxpw, 0, this.servo)\r\n            pins.servoSetPulse(this.pin, _angle)\r\n            //pins.servoWritePin(this.pin, _angle)\r\n        }\r\n\r\n        speed(_speed: number) {\r\n            _speed = Math.map(_speed, this.minpw, this.maxpw, -100, 100)\r\n            pins.servoSetPulse(this.pin, _speed)\r\n        }\r\n    }\r\n\r\n    export function create(_pin: AnalogPin, _type: ServoType): Device {\r\n        let device = new Device(_pin, _type)\r\n        return device\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////\r\n//#####################//\r\n//##                 ##//\r\n//##  cutebotpro.ts  ##//\r\n//##                 ##//\r\n//#####################//\r\n/////////////////////////\r\n\r\nenum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n}\r\n\r\nenum ServoPort {\r\n    S1,\r\n    S2,\r\n    S3,\r\n    S4,\r\n}\r\n\r\nenum GpioPort {\r\n    G1,\r\n    G2,\r\n    G3,\r\n    G4,\r\n}\r\n\r\nnamespace CutebotPro {\r\n    // supports CutebotPro V2\r\n\r\n    const cutebotProAddr = 0x10\r\n\r\n    let trackType = TrackType.BlackOnWhite\r\n\r\n    let AnalogGP = [AnalogPin.P1, AnalogPin.P2, AnalogPin.P13, AnalogPin.P14]\r\n    let DigitalGP = [DigitalPin.P1, DigitalPin.P2, DigitalPin.P13, DigitalPin.P14]\r\n\r\n    function delay_ms(ms: number) {\r\n        let endTime = input.runningTime() + ms;\r\n        while (endTime > input.runningTime()) { }\r\n    }\r\n\r\n    export function pid_delay_ms(ms: number) {\r\n        let time = control.millis() + ms\r\n        while (1) {\r\n            i2cCommandSend(0xA0, [0x05])\r\n            if (pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false) || control.millis() >= time) {\r\n                basic.pause(500)\r\n                break\r\n            }\r\n            basic.pause(10)\r\n        }\r\n    }\r\n\r\n    export function i2cCommandSend(command: number, params: number[]) {\r\n        let buff = pins.createBuffer(params.length + 4);\r\n        buff[0] = 0xFF;\r\n        buff[1] = 0xF9;\r\n        buff[2] = command;\r\n        buff[3] = params.length;\r\n        for (let i = 0; i < params.length; i++) {\r\n            buff[i + 4] = params[i];\r\n        }\r\n        pins.i2cWriteBuffer(cutebotProAddr, buff);\r\n        delay_ms(1);\r\n    }\r\n\r\n    // MOTION MODULE\r\n\r\n    export function speed(left: number, right: number): void {\r\n        // speed in % [-100, 100]\r\n\r\n        let direction: number = 0;\r\n        if (left < 0) direction |= 0x01;\r\n        if (right < 0) direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(left), Math.abs(right), direction]);\r\n    }\r\n\r\n    export function move(speed: number, distance: number): void {\r\n        // speed in % [-100, -40] backward and [40, 100] forward\r\n        // distance in cm [0, 6000]\r\n\r\n        distance = ((distance > 6000 ? 6000 : distance) < 0 ? 0 : distance);\r\n        distance *= 10 // cm to mm\r\n        let distance_h = distance >> 8;\r\n        let distance_l = distance & 0xFF;\r\n\r\n        let direction2: number\r\n        if (speed <= 0) {\r\n            speed = -speed\r\n            direction2 = 3\r\n        } else\r\n            direction2 = 0\r\n\r\n        speed *= 5 // % to mm/s\r\n        speed = ((speed > 500 ? 500 : speed) < 200 ? 200 : speed);\r\n        let speed_h = speed >> 8;\r\n        let speed_l = speed & 0xFF;\r\n\r\n        i2cCommandSend(0x84, [distance_h, distance_l, speed_h, speed_l, direction2]);\r\n        pid_delay_ms(Math.round(distance * 1.0 / 1000 * 8000 + 3000))\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function motor(speed: number): void {\r\n        let direction: number = (speed > 0 ? 1 : 0)\r\n        i2cCommandSend(0x30, [Math.abs(speed), direction])\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    export function servoAngle(port: ServoPort, angle: number, _type: ServoType = ServoType.ST180) {\r\n        angle = Math.map(angle, 0, _type, 0, 180)\r\n        i2cCommandSend(0x40, [port, angle])\r\n    }\r\n\r\n    export function servoSpeed(port: ServoPort, speed: number) {\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        i2cCommandSend(0x40, [port, speed])\r\n    }\r\n\r\n    // LED MODULE\r\n\r\n    export function ledColor(led: Led, color: Color): void {\r\n        let rgbval = fromColor(color)\r\n        let red = (rgbval >> 16) & 0xFF;\r\n        let green = (rgbval >> 8) & 0xFF;\r\n        let blue = (rgbval) & 0xFF;\r\n        i2cCommandSend(0x20, [led, red, green, blue]);\r\n    }\r\n\r\n    // TRACKING MODULE\r\n\r\n    export function setTrackType(_type: TrackType) {\r\n        trackType = _type\r\n    }\r\n\r\n    export function readTrack(): Track {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = (state & 3) + ((state & 12) << 1)\r\n        track = trackPosition(track, TrackMask.Track4, trackType)\r\n        return track\r\n    }\r\n\r\n    export function isTrackAtLeft(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Left || track == Track.FarLeft)\r\n    }\r\n\r\n    export function isTrackAtRight(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Right || track == Track.FarRight)\r\n    }\r\n\r\n    export function isOnTrack(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Mid)\r\n    }\r\n\r\n    export function isOffTrack(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.OffTrack)\r\n    }\r\n\r\n    // DISTANCE MODULE\r\n\r\n    export function readDistance(): number {\r\n        // send pulse\r\n\r\n        pins.setPull(DigitalPin.P8, PinPullMode.PullNone);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(DigitalPin.P8, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n\r\n        // read pulse\r\n\r\n        // the next code is replacing the original since\r\n        // driving the motors causes interference with pulseIn\r\n\r\n        while (!pins.digitalReadPin(DigitalPin.P12)) { }\r\n        let tm1 = input.runningTimeMicros()\r\n        while (pins.digitalReadPin(DigitalPin.P12)) {\r\n            if (input.runningTimeMicros() - tm1 > 7288)\r\n                return 999 // timeout at further than 250 cm\r\n        }\r\n        let tm2 = input.runningTimeMicros()\r\n        let dist = (tm2 - tm1) * 343 / 20000\r\n        return Math.floor(dist)\r\n    }\r\n\r\n    // GPIO MODULE\r\n\r\n    export function analogPin(port: GpioPort): AnalogPin {\r\n        return AnalogGP[port]\r\n    }\r\n\r\n    export function digitalPin(port: GpioPort): DigitalPin {\r\n        return DigitalGP[port]\r\n    }\r\n}\r\n\r\n\r\n//////////////////////////\r\n//######################//\r\n//##                  ##//\r\n//##  sumo-player.ts  ##//\r\n//##                  ##//\r\n//######################//\r\n//////////////////////////\r\n\r\nlet ROLE = Player.Green\r\n\r\nenum Bend {\r\n    //% block=\"go straight\"\r\n    //% block.loc.nl=\"ga rechtdoor\"\r\n    None,\r\n    //% block=\"turn to the left\"\r\n    //% block.loc.nl=\"draai naar links\"\r\n    Left,\r\n    //% block=\"turn to the right\"\r\n    //% block.loc.nl=\"draai naar rechts\"\r\n    Right\r\n}\r\n\r\nenum Side {\r\n    //% block=\"one of the sides\"\r\n    //% block.loc.nl=\"n van beide kanten\"\r\n    Both,\r\n    //% block=\"the left side\"\r\n    //% block.loc.nl=\"de linker kant\"\r\n    Left,\r\n    //% block=\"the right side\"\r\n    //% block.loc.nl=\"de rechter kant\"\r\n    Right\r\n}\r\n\r\n// setPlayerHandler is called from match.ts\r\nsetPlayerHandler = (player: Player) => {\r\n    ROLE = player\r\n}\r\n\r\n// showPlayerHandler is called from match.ts and this extension\r\nshowPlayerHandler = () => {\r\n    if (ROLE == Player.Green)\r\n        CutebotPro.ledColor(Led.Both, Color.Green)\r\n    else\r\n        CutebotPro.ledColor(Led.Both, Color.Blue)\r\n}\r\n\r\nresetHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nstopHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nif (initPlayerHandler) initPlayerHandler()\r\nif (displayHandler) displayHandler()\r\nCutebotPro.setTrackType(TrackType.WhiteOnBlack)\r\n\r\nlet outOfFieldHandler: handler\r\n\r\nbasic.forever(function () {\r\n    if (isPlaying && !isPlaying()) return\r\n    if (CutebotPro.readTrack() != Track.OffTrack) {\r\n        CutebotPro.ledColor(Led.Both, Color.Red)\r\n        if (outOfFieldHandler) outOfFieldHandler()\r\n    }\r\n    else {\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n})\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Sumo\"\r\n//% block.loc.nl=\"Sumo\"\r\nnamespace SumoPlayer {\r\n\r\n    let fielddiameter = 40 // cm\r\n\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"when the robot is out of the field\"\r\n    //% block.loc.nl=\"wanneer de robot buiten het speelveld is\"\r\n    export function onOutOfField(code: () => handler) {\r\n        outOfFieldHandler = code()\r\n    }\r\n\r\n    //% block=\"at %side out of the field\"\r\n    //% block=\"aan %side uit het veld\"\r\n    export function isOutOfField(side: Side): boolean {\r\n        switch (side) {\r\n            case Side.Both:     return !CutebotPro.isOffTrack()\r\n            case Side.Left:     return CutebotPro.isTrackAtLeft()\r\n            case Side.Right:    return CutebotPro.isTrackAtRight()\r\n        }\r\n        return false\r\n    }\r\n\r\n    //% block=\"stop\"\r\n    //% block.loc.nl=\"stop\"\r\n    export function stop() {\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"move %dir and %bend\"\r\n    //% block.loc.nl=\"rijd %dir en %bend\"\r\n    export function move(dir: Move, bend: Bend) {\r\n        let speed: number\r\n        if (dir == Move.Forward) speed = 20\r\n        else speed = -20\r\n        switch (bend) {\r\n            case Bend.None: CutebotPro.speed(speed, speed); break;\r\n            case Bend.Left: CutebotPro.speed(speed / 2, speed); break;\r\n            case Bend.Right: CutebotPro.speed(speed, speed / 2); break;\r\n        }\r\n    }\r\n\r\n    //% block=\"push the opponent\"\r\n    //% block.loc.nl=\"duw de tegenstander\"\r\n    export function pushOpponent() {\r\n        if (CutebotPro.readDistance() > 10) return\r\n        CutebotPro.speed(100, 100)\r\n    }\r\n\r\n    //% block=\"run to the opponent\"\r\n    //% block.loc.nl=\"rijd naar de tegenstander\"\r\n    export function runToOpponent() {\r\n        let cm: number\r\n        CutebotPro.speed(20, 20)\r\n        do {\r\n            if (isPlaying && !isPlaying()) return\r\n            cm = CutebotPro.readDistance()\r\n            basic.pause(10)\r\n        } while (cm > 10 && cm < fielddiameter)\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"turn to the opponent\"\r\n    //% block.loc.nl=\"draai richting tegenstander\"\r\n    export function findOpponent() {\r\n        CutebotPro.speed(-15, 15)\r\n        while (CutebotPro.readDistance() > fielddiameter) {\r\n            if (isPlaying && !isPlaying()) return\r\n            basic.pause(1)\r\n        }\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn %led color %color\"\r\n    //% block.loc.nl=\"kleur %led %color\"\r\n    //% color.defl=Color.White\r\n    export function showColor(led: Led, color: Color) {\r\n        CutebotPro.ledColor(led, color)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn both leds off\"\r\n    //% block.loc.nl=\"schakel beide leds uit\"\r\n    export function turnLedsOff() {\r\n        CutebotPro.ledColor(Led.Both, Color.None)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"tornado\"\r\n    //% block.loc.nl=\"tornado\"\r\n    export function tornado() {\r\n        let on = true\r\n        for (let speed = 10; speed < 50; speed += 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Black)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        for (let speed = 50; speed >= 0; speed -= 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Black)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(200)\r\n        }\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"shake\"\r\n    //% block.loc.nl=\"schudden\"\r\n    export function shake() {\r\n        for (let i = 0; i < 6; i++) {\r\n            if (showPlayerHandler) showPlayerHandler()\r\n            CutebotPro.speed(30, 30)\r\n            basic.pause(200)\r\n            CutebotPro.ledColor(Led.Both, Color.Magenta)\r\n            CutebotPro.speed(-30, -30)\r\n            basic.pause(230)\r\n        }\r\n        CutebotPro.speed(0, 0)\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n}\r\n\r\n\r\n\r\n////////////////////\r\n// TEST-PROGRAMMA //\r\n////////////////////\r\n\r\nMATCH = MatchStatus.Play\r\n\r\nbasic.forever(function() {\r\n    SumoPlayer.shake()\r\n    General.wait(5)\r\n})\r\n\r\n","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:ETmbit/general#50a144080fdbd8fb9bbefaa9a369108262fa31d4\",\n        \"match\": \"github:ETmbit/match#191656141aa933f8a0672849baaa5e4ad64b18fa\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1758452924027,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"////////////////////\r\n//################//\r\n//##            ##//\r\n//##  track.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum TrackType {\r\n    //% block=\"black on white\"\r\n    //% block.loc.nl=\"zwart op wit\"\r\n    BlackOnWhite,\r\n    //% block=\"white on black\"\r\n    //% block.loc.nl=\"wit op zwart\"\r\n    WhiteOnBlack,\r\n}\r\n\r\nenum TrackMask {\r\n    //% block=\"two sensors\"\r\n    //% block.loc.nl=\"twee sensoren\"\r\n    Track2 = 10,\r\n    //% block=\"three sensors\"\r\n    //% block.loc.nl=\"drie sensoren\"\r\n    Track3 = 14,\r\n    //% block=\"four sensors\"\r\n    //% block.loc.nl=\"vier sensoren\"\r\n    Track4 = 27,\r\n    //% block=\"five sensors\"\r\n    //% block.loc.nl=\"vijf sensoren\"\r\n    Track5 = 31,\r\n}\r\n\r\nenum Track {\r\n    //% block=\"off the track\"\r\n    //% block.loc.nl=\"van de lijn af\"\r\n    OffTrack = 0,\r\n    //% block=\"the track at far left\"\r\n    //% block.loc.nl=\"de lijn op uiterst links\"\r\n    FarLeft = 1,\r\n    //% block=\"the track at left\"\r\n    //% block.loc.nl=\"de lijn op links\"\r\n    Left = 2,\r\n    //% block=\"on the track\"\r\n    //% block.loc.nl=\"op de lijn\"\r\n    Mid = 4,\r\n    //% block=\"the track at right\"\r\n    //% block.loc.nl=\"de lijn op rechts\"\r\n    Right = 8,\r\n    //% block=\"the track at far right\"\r\n    //% block.loc.nl=\"de lijn op uiterst rechts\"\r\n    FarRight = 16,\r\n}\r\n\r\nfunction trackPosition(track: number, mask = TrackMask.Track2, tracktype = TrackType.BlackOnWhite): Track {\r\n    if (tracktype == TrackType.WhiteOnBlack) track = ~track\r\n    track = (track & mask)\r\n\r\n    if (!track)\r\n        return Track.OffTrack\r\n    if (track & 17) { // extreme left or right sensor\r\n        if (track & 4) { // mid sensor too\r\n            if (track & 1) return Track.Left\r\n            if (track & 16) return Track.Right\r\n        }\r\n        else { // whitout mid sensor\r\n            if (track & 1) return Track.FarLeft\r\n            if (track & 16) return Track.FarRight\r\n        }\r\n    }\r\n    if (((track & 10) == 10) ||   // both left and right sensor\r\n        ((track & 4) == track)) // mid sensor only\r\n        return Track.Mid\r\n    if (track & 2)\r\n        return Track.Left\r\n    if (track & 8)\r\n        return Track.Right\r\n    return Track.OffTrack\r\n}\r\n\r\n\r\n////////////////////\r\n//################//\r\n//##            ##//\r\n//##  servo.ts  ##//\r\n//##            ##//\r\n//################//\r\n////////////////////\r\n\r\nenum ServoType {\r\n    Continuous = 0,\r\n    ST90 = 90,\r\n    ST180 = 180,\r\n    ST270 = 270,\r\n    ST360 = 360,\r\n}\r\n\r\nnamespace Servo {\r\n\r\n    export class Device {\r\n\r\n        pin: AnalogPin\r\n        servo: ServoType\r\n        minpw: number = 1000\r\n        maxpw: number = 2000\r\n\r\n        constructor(_pin: AnalogPin, _type: ServoType) {\r\n            this.pin = _pin\r\n            this.servo = _type\r\n        }\r\n\r\n        setPulse(_min: number, _max: number) {\r\n            this.minpw = _min;\r\n            this.maxpw = _max;\r\n        }\r\n\r\n        angle(_angle: number) {\r\n            _angle = Math.map(_angle, this.minpw, this.maxpw, 0, this.servo)\r\n            pins.servoSetPulse(this.pin, _angle)\r\n            //pins.servoWritePin(this.pin, _angle)\r\n        }\r\n\r\n        speed(_speed: number) {\r\n            _speed = Math.map(_speed, this.minpw, this.maxpw, -100, 100)\r\n            pins.servoSetPulse(this.pin, _speed)\r\n        }\r\n    }\r\n\r\n    export function create(_pin: AnalogPin, _type: ServoType): Device {\r\n        let device = new Device(_pin, _type)\r\n        return device\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////\r\n//#####################//\r\n//##                 ##//\r\n//##  cutebotpro.ts  ##//\r\n//##                 ##//\r\n//#####################//\r\n/////////////////////////\r\n\r\nenum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n}\r\n\r\nenum ServoPort {\r\n    S1,\r\n    S2,\r\n    S3,\r\n    S4,\r\n}\r\n\r\nenum GpioPort {\r\n    G1,\r\n    G2,\r\n    G3,\r\n    G4,\r\n}\r\n\r\nnamespace CutebotPro {\r\n    // supports CutebotPro V2\r\n\r\n    const cutebotProAddr = 0x10\r\n\r\n    let trackType = TrackType.BlackOnWhite\r\n\r\n    let AnalogGP = [AnalogPin.P1, AnalogPin.P2, AnalogPin.P13, AnalogPin.P14]\r\n    let DigitalGP = [DigitalPin.P1, DigitalPin.P2, DigitalPin.P13, DigitalPin.P14]\r\n\r\n    function delay_ms(ms: number) {\r\n        let endTime = input.runningTime() + ms;\r\n        while (endTime > input.runningTime()) { }\r\n    }\r\n\r\n    export function pid_delay_ms(ms: number) {\r\n        let time = control.millis() + ms\r\n        while (1) {\r\n            i2cCommandSend(0xA0, [0x05])\r\n            if (pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false) || control.millis() >= time) {\r\n                basic.pause(500)\r\n                break\r\n            }\r\n            basic.pause(10)\r\n        }\r\n    }\r\n\r\n    export function i2cCommandSend(command: number, params: number[]) {\r\n        let buff = pins.createBuffer(params.length + 4);\r\n        buff[0] = 0xFF;\r\n        buff[1] = 0xF9;\r\n        buff[2] = command;\r\n        buff[3] = params.length;\r\n        for (let i = 0; i < params.length; i++) {\r\n            buff[i + 4] = params[i];\r\n        }\r\n        pins.i2cWriteBuffer(cutebotProAddr, buff);\r\n        delay_ms(1);\r\n    }\r\n\r\n    // MOTION MODULE\r\n\r\n    export function speed(left: number, right: number): void {\r\n        // speed in % [-100, 100]\r\n\r\n        let direction: number = 0;\r\n        if (left < 0) direction |= 0x01;\r\n        if (right < 0) direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(left), Math.abs(right), direction]);\r\n    }\r\n\r\n    export function move(speed: number, distance: number): void {\r\n        // speed in % [-100, -40] backward and [40, 100] forward\r\n        // distance in cm [0, 6000]\r\n\r\n        distance = ((distance > 6000 ? 6000 : distance) < 0 ? 0 : distance);\r\n        distance *= 10 // cm to mm\r\n        let distance_h = distance >> 8;\r\n        let distance_l = distance & 0xFF;\r\n\r\n        let direction2: number\r\n        if (speed <= 0) {\r\n            speed = -speed\r\n            direction2 = 3\r\n        } else\r\n            direction2 = 0\r\n\r\n        speed *= 5 // % to mm/s\r\n        speed = ((speed > 500 ? 500 : speed) < 200 ? 200 : speed);\r\n        let speed_h = speed >> 8;\r\n        let speed_l = speed & 0xFF;\r\n\r\n        i2cCommandSend(0x84, [distance_h, distance_l, speed_h, speed_l, direction2]);\r\n        pid_delay_ms(Math.round(distance * 1.0 / 1000 * 8000 + 3000))\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function motor(speed: number): void {\r\n        let direction: number = (speed > 0 ? 1 : 0)\r\n        i2cCommandSend(0x30, [Math.abs(speed), direction])\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    export function servoAngle(port: ServoPort, angle: number, _type: ServoType = ServoType.ST180) {\r\n        angle = Math.map(angle, 0, _type, 0, 180)\r\n        i2cCommandSend(0x40, [port, angle])\r\n    }\r\n\r\n    export function servoSpeed(port: ServoPort, speed: number) {\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        i2cCommandSend(0x40, [port, speed])\r\n    }\r\n\r\n    // LED MODULE\r\n\r\n    export function ledColor(led: Led, color: Color): void {\r\n        let rgbval = fromColor(color)\r\n        let red = (rgbval >> 16) & 0xFF;\r\n        let green = (rgbval >> 8) & 0xFF;\r\n        let blue = (rgbval) & 0xFF;\r\n        i2cCommandSend(0x20, [led, red, green, blue]);\r\n    }\r\n\r\n    // TRACKING MODULE\r\n\r\n    export function setTrackType(_type: TrackType) {\r\n        trackType = _type\r\n    }\r\n\r\n    export function readTrack(): Track {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        // From left to right the track sensors represent a bit in 'state'.\r\n        // This agrees with the 'Track' extension. So use it without conversion.\r\n        let track = (state & 3) + ((state & 12) << 1)\r\n        track = trackPosition(track, TrackMask.Track4, trackType)\r\n        return track\r\n    }\r\n\r\n    export function isTrackAtLeft(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Left || track == Track.FarLeft)\r\n    }\r\n\r\n    export function isTrackAtRight(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Right || track == Track.FarRight)\r\n    }\r\n\r\n    export function isOnTrack(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.Mid)\r\n    }\r\n\r\n    export function isOffTrack(): boolean {\r\n        let state = readTrack()\r\n        let track = trackPosition(state, TrackMask.Track4, trackType)\r\n        return (track == Track.OffTrack)\r\n    }\r\n\r\n    // DISTANCE MODULE\r\n\r\n    export function readDistance(): number {\r\n        // send pulse\r\n\r\n        pins.setPull(DigitalPin.P8, PinPullMode.PullNone);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(DigitalPin.P8, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n\r\n        // read pulse\r\n\r\n        // the next code is replacing the original since\r\n        // driving the motors causes interference with pulseIn\r\n\r\n        while (!pins.digitalReadPin(DigitalPin.P12)) { }\r\n        let tm1 = input.runningTimeMicros()\r\n        while (pins.digitalReadPin(DigitalPin.P12)) {\r\n            if (input.runningTimeMicros() - tm1 > 7288)\r\n                return 999 // timeout at further than 250 cm\r\n        }\r\n        let tm2 = input.runningTimeMicros()\r\n        let dist = (tm2 - tm1) * 343 / 20000\r\n        return Math.floor(dist)\r\n    }\r\n\r\n    // GPIO MODULE\r\n\r\n    export function analogPin(port: GpioPort): AnalogPin {\r\n        return AnalogGP[port]\r\n    }\r\n\r\n    export function digitalPin(port: GpioPort): DigitalPin {\r\n        return DigitalGP[port]\r\n    }\r\n}\r\n\r\n\r\n//////////////////////////\r\n//######################//\r\n//##                  ##//\r\n//##  sumo-player.ts  ##//\r\n//##                  ##//\r\n//######################//\r\n//////////////////////////\r\n\r\nlet ROLE = Player.Green\r\n\r\nenum Bend {\r\n    //% block=\"go straight\"\r\n    //% block.loc.nl=\"ga rechtdoor\"\r\n    None,\r\n    //% block=\"turn to the left\"\r\n    //% block.loc.nl=\"draai naar links\"\r\n    Left,\r\n    //% block=\"turn to the right\"\r\n    //% block.loc.nl=\"draai naar rechts\"\r\n    Right\r\n}\r\n\r\nenum Side {\r\n    //% block=\"one of the sides\"\r\n    //% block.loc.nl=\"n van beide kanten\"\r\n    Both,\r\n    //% block=\"the left side\"\r\n    //% block.loc.nl=\"de linker kant\"\r\n    Left,\r\n    //% block=\"the right side\"\r\n    //% block.loc.nl=\"de rechter kant\"\r\n    Right\r\n}\r\n\r\n// setPlayerHandler is called from match.ts\r\nsetPlayerHandler = (player: Player) => {\r\n    ROLE = player\r\n}\r\n\r\n// showPlayerHandler is called from match.ts and this extension\r\nshowPlayerHandler = () => {\r\n    if (ROLE == Player.Green)\r\n        CutebotPro.ledColor(Led.Both, Color.Green)\r\n    else\r\n        CutebotPro.ledColor(Led.Both, Color.Blue)\r\n}\r\n\r\nresetHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nstopHandler = () => {\r\n    SumoPlayer.stop()\r\n}\r\n\r\nif (initPlayerHandler) initPlayerHandler()\r\nif (displayHandler) displayHandler()\r\nCutebotPro.setTrackType(TrackType.WhiteOnBlack)\r\n\r\nlet outOfFieldHandler: handler\r\n\r\nbasic.forever(function () {\r\n    if (isPlaying && !isPlaying()) return\r\n    if (CutebotPro.readTrack() != Track.OffTrack) {\r\n        CutebotPro.ledColor(Led.Both, Color.Red)\r\n        if (outOfFieldHandler) outOfFieldHandler()\r\n    }\r\n    else {\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n})\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Sumo\"\r\n//% block.loc.nl=\"Sumo\"\r\nnamespace SumoPlayer {\r\n\r\n    let fielddiameter = 40 // cm\r\n\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"when the robot is out of the field\"\r\n    //% block.loc.nl=\"wanneer de robot buiten het speelveld is\"\r\n    export function onOutOfField(code: () => handler) {\r\n        outOfFieldHandler = code()\r\n    }\r\n\r\n    //% block=\"at %side out of the field\"\r\n    //% block=\"aan %side uit het veld\"\r\n    export function isOutOfField(side: Side): boolean {\r\n        switch (side) {\r\n            case Side.Both:     return !CutebotPro.isOffTrack()\r\n            case Side.Left:     return CutebotPro.isTrackAtLeft()\r\n            case Side.Right:    return CutebotPro.isTrackAtRight()\r\n        }\r\n        return false\r\n    }\r\n\r\n    //% block=\"stop\"\r\n    //% block.loc.nl=\"stop\"\r\n    export function stop() {\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"move %dir and %bend\"\r\n    //% block.loc.nl=\"rijd %dir en %bend\"\r\n    export function move(dir: Move, bend: Bend) {\r\n        let speed: number\r\n        if (dir == Move.Forward) speed = 20\r\n        else speed = -20\r\n        switch (bend) {\r\n            case Bend.None: CutebotPro.speed(speed, speed); break;\r\n            case Bend.Left: CutebotPro.speed(speed / 2, speed); break;\r\n            case Bend.Right: CutebotPro.speed(speed, speed / 2); break;\r\n        }\r\n    }\r\n\r\n    //% block=\"push the opponent\"\r\n    //% block.loc.nl=\"duw de tegenstander\"\r\n    export function pushOpponent() {\r\n        if (CutebotPro.readDistance() > 10) return\r\n        CutebotPro.speed(100, 100)\r\n    }\r\n\r\n    //% block=\"run to the opponent\"\r\n    //% block.loc.nl=\"rijd naar de tegenstander\"\r\n    export function runToOpponent() {\r\n        let cm: number\r\n        CutebotPro.speed(20, 20)\r\n        do {\r\n            if (isPlaying && !isPlaying()) return\r\n            cm = CutebotPro.readDistance()\r\n            basic.pause(10)\r\n        } while (cm > 10 && cm < fielddiameter)\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% block=\"turn to the opponent\"\r\n    //% block.loc.nl=\"draai richting tegenstander\"\r\n    export function findOpponent() {\r\n        CutebotPro.speed(-15, 15)\r\n        while (CutebotPro.readDistance() > fielddiameter) {\r\n            if (isPlaying && !isPlaying()) return\r\n            basic.pause(1)\r\n        }\r\n        CutebotPro.speed(0, 0)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn %led color %color\"\r\n    //% block.loc.nl=\"kleur %led %color\"\r\n    //% color.defl=Color.White\r\n    export function showColor(led: Led, color: Color) {\r\n        CutebotPro.ledColor(led, color)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#00CC00\"\r\n    //% block=\"turn both leds off\"\r\n    //% block.loc.nl=\"schakel beide leds uit\"\r\n    export function ledsOff() {\r\n        CutebotPro.ledColor(Led.Both, Color.None)\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"tornado\"\r\n    //% block.loc.nl=\"tornado\"\r\n    export function tornado() {\r\n        let on = true\r\n        for (let speed = 10; speed < 75; speed += 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Magenta)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(168)\r\n        }\r\n        for (let speed = 75; speed >= 0; speed -= 5) {\r\n            if (on)\r\n                CutebotPro.ledColor(Led.Both, Color.Magenta)\r\n            else\r\n                if (showPlayerHandler) showPlayerHandler()\r\n            on = !on\r\n            CutebotPro.speed(speed, -speed)\r\n            basic.pause(168)\r\n        }\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n\r\n    //% subcategory=\"Show\"\r\n    //% color=\"#FFCC44\"\r\n    //% block=\"shake\"\r\n    //% block.loc.nl=\"schudden\"\r\n    export function shake() {\r\n        for (let i = 0; i < 6; i++) {\r\n            CutebotPro.ledColor(Led.Both, Color.Magenta)\r\n            CutebotPro.speed(30, 30)\r\n            basic.pause(200)\r\n            if (showPlayerHandler) showPlayerHandler()\r\n            CutebotPro.speed(-30, -30)\r\n            basic.pause(230)\r\n        }\r\n        CutebotPro.speed(0, 0)\r\n        if (showPlayerHandler) showPlayerHandler()\r\n    }\r\n}\r\n\r\n\r\n\r\n////////////////////\r\n// TEST-PROGRAMMA //\r\n////////////////////\r\n\r\n//MATCH = MatchStatus.Play\r\n\r\nbasic.forever(function() {\r\n    SumoPlayer.move(Move.Forward, Bend.Left)\r\n    General.wait(1)\r\n    SumoPlayer.stop()\r\n    SumoPlayer.move(Move.Backward, Bend.Left)\r\n    General.wait(1)\r\n    SumoPlayer.stop()\r\n    General.wait(5)\r\n})\r\n\r\n","README.md":"","pxt.json":"{\n    \"name\": \"test-sumo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"general\": \"github:ETmbit/general#50a144080fdbd8fb9bbefaa9a369108262fa31d4\",\n        \"match\": \"github:ETmbit/match#191656141aa933f8a0672849baaa5e4ad64b18fa\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1758453074730}